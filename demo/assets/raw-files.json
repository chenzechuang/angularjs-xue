{"banner":"/**\n * angularjs-xue\n * Homepage: https://github.com/zhangxuelian/angularjs-xue\n * \n * Version: 1.0.0 - 2020-02-20\n * Require angularjs version: 1.2.32\n * License: ISC\n */\n","cssBanner":"/* Include this file in your html if you are using the CSP mode. */\n\n","files":{"src/pagination/pagination.js":"angular.module('xue.pagination', [])\r\n\r\n  .controller('xuePaginationController', ['$scope', '$attrs', '$parse', function ($scope, $attrs, $parse) {\r\n    var self = this,\r\n      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\r\n      setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;\r\n\r\n    this.init = function (ngModelCtrl_, config) {\r\n      ngModelCtrl = ngModelCtrl_;\r\n      this.config = config;\r\n\r\n      ngModelCtrl.$render = function () {\r\n        self.render();\r\n      };\r\n\r\n      if ($attrs.itemsPerPage) {\r\n        $scope.$parent.$watch($parse($attrs.itemsPerPage), function (value) {\r\n          self.itemsPerPage = parseInt(value, 10);\r\n          $scope.totalPages = self.calculateTotalPages();\r\n        });\r\n      } else {\r\n        this.itemsPerPage = config.itemsPerPage;\r\n      }\r\n    };\r\n\r\n    this.calculateTotalPages = function () {\r\n      var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);\r\n      return Math.max(totalPages || 0, 1);\r\n    };\r\n\r\n    this.render = function () {\r\n      $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;\r\n    };\r\n\r\n    $scope.selectPage = function (page) {\r\n      if ($scope.page !== page && page > 0 && page <= $scope.totalPages) {\r\n        ngModelCtrl.$setViewValue(page);\r\n        ngModelCtrl.$render();\r\n      }\r\n    };\r\n\r\n    $scope.getText = function (key) {\r\n      return $scope[key + 'Text'] || self.config[key + 'Text'];\r\n    };\r\n    $scope.noPrevious = function () {\r\n      return $scope.page === 1;\r\n    };\r\n    $scope.noNext = function () {\r\n      return $scope.page === $scope.totalPages;\r\n    };\r\n\r\n    $scope.$watch('totalItems', function () {\r\n      $scope.totalPages = self.calculateTotalPages();\r\n    });\r\n\r\n    $scope.$watch('totalPages', function (value) {\r\n      setNumPages($scope.$parent, value); // Readonly variable\r\n\r\n      if ($scope.page > value) {\r\n        $scope.selectPage(value);\r\n      } else {\r\n        ngModelCtrl.$render();\r\n      }\r\n    });\r\n  }])\r\n\r\n  .constant('xuePaginationConfig', {\r\n    itemsPerPage: 10,\r\n    boundaryLinks: false,\r\n    directionLinks: true,\r\n    firstText: '首页',\r\n    previousText: '上页',\r\n    nextText: '下页',\r\n    lastText: '尾页',\r\n    rotate: true\r\n  })\r\n\r\n  .directive('xuePagination', ['$parse', 'xuePaginationConfig', function ($parse, paginationConfig) {\r\n    return {\r\n      restrict: 'EA',\r\n      scope: {\r\n        totalItems: '=',\r\n        firstText: '@',\r\n        previousText: '@',\r\n        nextText: '@',\r\n        lastText: '@'\r\n      },\r\n      require: ['xuePagination', '?ngModel'],\r\n      controller: 'xuePaginationController',\r\n      templateUrl: function (element, attrs) {\r\n        return attrs.templateUrl || 'xue/template/pagination/pagination.html';\r\n      },\r\n      replace: true,\r\n      link: function (scope, element, attrs, ctrls) {\r\n        var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\r\n\r\n        if (!ngModelCtrl) {\r\n          return; // do nothing if no ng-model\r\n        }\r\n\r\n        // Setup configuration parameters\r\n        var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,\r\n          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;\r\n        scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;\r\n        scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;\r\n\r\n        paginationCtrl.init(ngModelCtrl, paginationConfig);\r\n\r\n        if (attrs.maxSize) {\r\n          scope.$parent.$watch($parse(attrs.maxSize), function (value) {\r\n            maxSize = parseInt(value, 10);\r\n            paginationCtrl.render();\r\n          });\r\n        }\r\n\r\n        // Create page object used in template\r\n        function makePage(number, text, isActive) {\r\n          return {\r\n            number: number,\r\n            text: text,\r\n            active: isActive\r\n          };\r\n        }\r\n\r\n        function getPages(currentPage, totalPages) {\r\n          var pages = [];\r\n\r\n          // Default page limits\r\n          var startPage = 1, endPage = totalPages;\r\n          var isMaxSized = (angular.isDefined(maxSize) && maxSize < totalPages);\r\n\r\n          // recompute if maxSize\r\n          if (isMaxSized) {\r\n            if (rotate) {\r\n              // Current page is displayed in the middle of the visible ones\r\n              startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);\r\n              endPage = startPage + maxSize - 1;\r\n\r\n              // Adjust if limit is exceeded\r\n              if (endPage > totalPages) {\r\n                endPage = totalPages;\r\n                startPage = endPage - maxSize + 1;\r\n              }\r\n            } else {\r\n              // Visible pages are paginated with maxSize\r\n              startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;\r\n\r\n              // Adjust last page if limit is exceeded\r\n              endPage = Math.min(startPage + maxSize - 1, totalPages);\r\n            }\r\n          }\r\n\r\n          // Add page number links\r\n          for (var number = startPage; number <= endPage; number++) {\r\n            var page = makePage(number, number, number === currentPage);\r\n            pages.push(page);\r\n          }\r\n\r\n          // Add links to move between page sets\r\n          if (isMaxSized && !rotate) {\r\n            if (startPage > 1) {\r\n              var previousPageSet = makePage(startPage - 1, '...', false);\r\n              pages.unshift(previousPageSet);\r\n            }\r\n\r\n            if (endPage < totalPages) {\r\n              var nextPageSet = makePage(endPage + 1, '...', false);\r\n              pages.push(nextPageSet);\r\n            }\r\n          }\r\n\r\n          return pages;\r\n        }\r\n\r\n        var originalRender = paginationCtrl.render;\r\n        paginationCtrl.render = function () {\r\n          originalRender();\r\n          if (scope.page > 0 && scope.page <= scope.totalPages) {\r\n            scope.pages = getPages(scope.page, scope.totalPages);\r\n          }\r\n        };\r\n      }\r\n    };\r\n  }])\r\n\r\n  .constant('xuePagerConfig', {\r\n    itemsPerPage: 10,\r\n    previousText: '« 上页',\r\n    nextText: '下页 »',\r\n    align: true\r\n  })\r\n\r\n  .directive('xuePager', ['xuePagerConfig', function (pagerConfig) {\r\n    return {\r\n      restrict: 'EA',\r\n      scope: {\r\n        totalItems: '=',\r\n        previousText: '@',\r\n        nextText: '@'\r\n      },\r\n      require: ['xuePager', '?ngModel'],\r\n      controller: 'xuePaginationController',\r\n      templateUrl: function (element, attrs) {\r\n        return attrs.templateUrl || 'xue/template/pagination/pager.html';\r\n      },\r\n      replace: true,\r\n      link: function (scope, element, attrs, ctrls) {\r\n        var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\r\n\r\n        if (!ngModelCtrl) {\r\n          return; // do nothing if no ng-model\r\n        }\r\n\r\n        scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;\r\n        paginationCtrl.init(ngModelCtrl, pagerConfig);\r\n      }\r\n    };\r\n  }]);","src/table/table.js":"angular.module('xue.table', ['xue.util.lang', 'xue.pagination'])\r\n    .directive('xueTable', ['xueUtilLang', function (xueUtilLang) {\r\n        return {\r\n            restrict: \"E\",\r\n            replace: true,\r\n            scope: {\r\n                tableConfig: '='\r\n            },\r\n            templateUrl: function (element, attrs) {\r\n                return attrs.templateUrl || 'xue/template/table/table.html';\r\n            },\r\n            link: function (scope, ele, attrs) {\r\n\r\n            }\r\n        };\r\n    }])","src/util/array.js":"angular.module('xue.util.array', []).service('xueUtilArray', [\r\n    function () {\r\n        /**\r\n         * 数组去重,数组元素为string\r\n         *\r\n         * @param {any} arr\r\n         * @returns\r\n         */\r\n        this.uniq = function (arr) {\r\n            var res = [];\r\n            var json = {};\r\n            for (var i = 0; i < arr.length; i++) {\r\n                if (!json[arr[i]]) {\r\n                    res.push(arr[i]);\r\n                    json[arr[i]] = 1;\r\n                }\r\n            }\r\n            return res;\r\n        };\r\n        /**\r\n         * 数组去重,数组元素为json\r\n         *\r\n         * @param {any} arr\r\n         * @param {any} key\r\n         * @returns\r\n         */\r\n        this.uniqJson = function (arr, key) {\r\n            var res = [];\r\n            var json = {};\r\n            angular.forEach(arr, function (item) {\r\n                if (!json[item[key]]) {\r\n                    res.push(item);\r\n                    json[item[key]] = 1;\r\n                }\r\n            });\r\n            return res;\r\n        };\r\n        /**\r\n         * 数组快速排序（数组对象为int型）\r\n         *\r\n         * @param {any} array\r\n         * @returns\r\n         */\r\n        /*eslint complexity: [\"error\", 7]*/\r\n        this.quickSort = function (array) {\r\n            function sort(prev, numsize) {\r\n                var nonius = prev;\r\n                var j = numsize - 1;\r\n                var flag = array[prev];\r\n                // eslint-disable-next-line no-extra-parens\r\n                if ((numsize - prev) > 1) {\r\n                    while (nonius < j) {\r\n                        for (; nonius < j; j--) {\r\n                            if (array[j] < flag) {\r\n                                //a[i] = a[j]; i += 1;\r\n                                array[nonius++] = array[j];\r\n                                break;\r\n                            }\r\n                        }\r\n                        for (; nonius < j; nonius++) {\r\n                            if (array[nonius] > flag) {\r\n                                array[j--] = array[nonius];\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    array[nonius] = flag;\r\n                    sort(0, nonius);\r\n                    sort(nonius + 1, numsize);\r\n                }\r\n            }\r\n            sort(0, array.length);\r\n            return array;\r\n        };\r\n        /**\r\n         * 从数组中查找对象属性值，返回下标（同用于判断数组中是否存在某对象）\r\n         * ps：数组对象为json\r\n         * @param {any} arr\r\n         * @param {any} key\r\n         * @param {any} value\r\n         * @returns\r\n         */\r\n        this.findObjIndex = function (arr, key, value) {\r\n            try {\r\n                for (var i = 0; i < arr.length; i++) {\r\n                    if (arr[i][key] === value) {\r\n                        return i;\r\n                    }\r\n                }\r\n                return -1;\r\n            } catch (e) {\r\n                return -1;\r\n            }\r\n        };\r\n        /**\r\n         * 从数组中查找值，返回下标（同用于判断数组中是否存在某对象）\r\n         * ps:数组对象为string\r\n         * @param {any} arr\r\n         * @param {any} value\r\n         * @returns\r\n         */\r\n        this.findStrIndex = function (arr, value) {\r\n            for (var i = 0; i < arr.length; i++) {\r\n                if (arr[i] === value) {\r\n                    return i;\r\n                }\r\n            }\r\n            return -1;\r\n        };\r\n\r\n    }\r\n]);","src/util/collection.js":"angular.module('xue.util.collection', ['xue.util.lang'])\r\n    .service('xueUtilCollect', [\"xueUtilLang\", function (xueUtilLang) {\r\n        /**\r\n         * 从数组中查找对象值，返回数组\r\n         * ps：数组元素为json，匹配对象为数组\r\n         * @param {any} arr\r\n         * @param {any} key\r\n         * @param {any} valueArr\r\n         * @returns\r\n         */\r\n        this.findWithArray = function (arr, key, valueArr) {\r\n            var ret = [];\r\n            for (var i = 0; i < arr.length; i++) {\r\n                for (var j in valueArr) {\r\n                    if (arr[i][key] === valueArr[j]) {\r\n                        ret.push(arr[i]);\r\n                        valueArr.splice(j, 1);\r\n                    }\r\n                }\r\n                if (valueArr.length === 0) {\r\n                    return ret;\r\n                }\r\n            }\r\n            return ret;\r\n        };\r\n        /**\r\n         * 从数组中查找对象值，返回对象\r\n         * ps：数组元素为json\r\n         * @param {any} arr\r\n         * @param {any} key\r\n         * @param {any} value\r\n         * @returns\r\n         */\r\n        this.findWithVal = function (arr, key, value) {\r\n            try {\r\n                for (var i = 0; i < arr.length; i++) {\r\n                    if (arr[i][key] === value) {\r\n                        return arr[i];\r\n                    }\r\n                }\r\n                return '';\r\n            } catch (e) {\r\n                return '';\r\n            }\r\n        };\r\n        /**\r\n         * 移除对象中值为空的项\r\n         *\r\n         * @param {obj} obj\r\n         * @returns\r\n         */\r\n        this.removeEmptyField = function (json) {\r\n            var newJson = {};\r\n            angular.forEach(json, function (item, i) {\r\n                if (item) {\r\n                    newJson[i] = item;\r\n                }\r\n            });\r\n            return newJson;\r\n        };\r\n        /**\r\n         * 移除数组中对象某属性值为空的项\r\n         *\r\n         * @param {array} array\r\n         * @returns\r\n         */\r\n        this.removeEmptyItem = function (array) {\r\n            var newArray = [];\r\n            for (var i = 0; i < array.length; i++) {\r\n                var newObj = {};\r\n                for (var j in array[i]) {\r\n                    if (array[i][j]) {\r\n                        newObj[j] = array[i][j];\r\n                    }\r\n                }\r\n                newArray.push(newObj);\r\n            }\r\n            return newArray;\r\n        };\r\n        /**\r\n         * 根据数组中对象的某个属性进行排序\r\n         * @param {Array} arr 数组\r\n         * @param {String} field 字段名\r\n         * @param {Boolean} order 排序方式 默认正序 true 倒序 false\r\n         * @param {String} type 排序类型 默认为0 数值类型 0 字符类型 1\r\n         */\r\n        /*eslint complexity: [\"error\", 8]*/\r\n        this.sortByfield = function (arr, field, order, type) {\r\n            var res = [];\r\n            if (arr.length && field) {\r\n                if (typeof order === 'undefined') {\r\n                    order = true;\r\n                } else {\r\n                    order = !!order;\r\n                }\r\n                if (typeof type === 'undefined') {\r\n                    type = isNaN(parseInt(arr[0][field], 0)) ? 1 : 0;\r\n                } else {\r\n                    type = type === 1 ? 1 : 0;\r\n                }\r\n                if (type === 0) {\r\n                    var compare = function () {\r\n                        return function (a, b) {\r\n                            var res;\r\n                            if (order) {\r\n                                res = a[field] - b[field];\r\n                            } else {\r\n                                res = b[field] - a[field];\r\n                            }\r\n                            return res;\r\n                        };\r\n                    };\r\n                    arr.sort(compare(field, order));\r\n                } else {\r\n                    var compareStr = function () {\r\n                        var e = order ? 1 : -1;\r\n                        return function (a, b) {\r\n                            var res;\r\n                            if (a[field] < b[field]) {\r\n                                res = -1 * e;\r\n                            } else if (a[field] > b[field]) {\r\n                                res = 1 * e;\r\n                            } else {\r\n                                res = 0;\r\n                            }\r\n                            return res;\r\n                        };\r\n                    };\r\n                    arr.sort(compareStr(field, order));\r\n                }\r\n                res = arr;\r\n            }\r\n            return res;\r\n        };\r\n        /**\r\n         * 判断是几维数组(返回数组中最大的维度)\r\n         */\r\n        this.arrDimension = function (arr, dimension) {\r\n            if (!dimension) {\r\n                dimension = 0;\r\n            }\r\n            var res;\r\n            if (arr instanceof Array) {\r\n                dimension++;\r\n                var maxDimension = 0,\r\n                    tempDimension = dimension,\r\n                    temp = 0;\r\n                for (var i = 0; i < arr.length; i++) {\r\n                    temp = this.arrDimension(arr[i], tempDimension);\r\n                    if (temp > maxDimension) {\r\n                        maxDimension = temp;\r\n                    }\r\n                }\r\n                res = maxDimension;\r\n            } else {\r\n                res = dimension;\r\n            }\r\n            return res;\r\n        };\r\n        /**\r\n         * 获取字节长度（英文数字占1个字符，中文汉字占2个字符）\r\n         * @param {string} str \r\n         */\r\n        this.getByteLen = function (str) {\r\n            var len = 0;\r\n            for (var i = 0; i < str.length; i++) {\r\n                var c = str.charCodeAt(i);\r\n                //单字节加1\r\n                if (c >= 0x0001 && c <= 0x007e || c >= 0xff60 && c <= 0xff9f) {\r\n                    len++;\r\n                } else {\r\n                    len += 2;\r\n                }\r\n            }\r\n            return len;\r\n        };\r\n        /**\r\n         * 按长度切割数组/字符串\r\n         * @param {array/string} param \r\n         * @param {int} len 中文字符长度，通过字节长度来切割的，则字节长度为len的两倍\r\n         * @param {bool} isByteLen 是否是字节长度 (目前仅字符串支持通过字节长度切割)\r\n         */\r\n        /*eslint complexity: [\"error\", 10]*/\r\n        this.sliceByLen = function (param, len, isByteLen) {\r\n            try {\r\n                var newArr = [],\r\n                    i;\r\n                if (isByteLen && xueUtilLang.isType(param || '', 'string')) {\r\n                    var byteLen = len * 2,\r\n                        tempStr = '',\r\n                        tempCount = 0;\r\n                    for (i = 0; i < param.length; i++) {\r\n                        tempCount += this.getByteLen(param.charAt(i));\r\n                        tempStr += param.charAt(i);\r\n                        if (tempCount >= byteLen) {\r\n                            newArr.push(tempStr);\r\n                            tempStr = '';\r\n                            tempCount = 0;\r\n                        }\r\n                    }\r\n                    if (tempCount) {\r\n                        newArr.push(tempStr);\r\n                    }\r\n                } else {\r\n                    var sliceTime = Math.ceil(param.length / len);\r\n                    for (i = 0; i < sliceTime; i++) {\r\n                        newArr.push(param.slice(i * len, i * len + len));\r\n                    }\r\n                }\r\n                return newArr;\r\n            } catch (e) {\r\n                return param || [];\r\n            }\r\n        };\r\n    }]);","src/util/date.js":"angular.module('xue.util.date', ['xue.util.lang'])\r\n    .service('xueUtilDate', ['xueUtilLang', function (xueUtilLang) {\r\n        var self = this;\r\n        /**\r\n         * 格式化时间\r\n         * 根据给定格式格式化时间 时间可以是标准时间或者符合时间格式的字符串\r\n         * @param {any} date /Mon Nov 20 2017 14:28:48 GMT+0800 (中国标准时间)/ 2020-2-20\r\n         * @param {string} fmt 可选 时间格式 默认YYYY-MM-DD hh:mm:ss\r\n         * @returns {String} /2016-01-01 23:59:59/\r\n         */\r\n        this.formatDate = function(date, fmt) {\r\n            date = new Date(date);\r\n            if (!xueUtilLang.isDate(date)) {\r\n                return \"Invalid Date\";\r\n            }\r\n            fmt = fmt ? fmt : \"YYYY-MM-DD hh:mm:ss\";\r\n            var opt = {\r\n                \"Y+\": date.getFullYear().toString(), // 年\r\n                \"M+\": (date.getMonth() + 1).toString(), // 月\r\n                \"D+\": date.getDate().toString(), // 日\r\n                \"h+\": date.getHours().toString(), // 时\r\n                \"m+\": date.getMinutes().toString(), // 分\r\n                \"s+\": date.getSeconds().toString() // 秒\r\n                // 有其他格式化字符需求可以继续添加，必须转化成字符串\r\n            };\r\n            for (var k in opt) {\r\n                var ret = new RegExp(\"(\" + k + \")\").exec(fmt);\r\n                if (ret) {\r\n                    fmt = fmt.replace(ret[1], (ret[1].length == 1) ? (opt[k]) : (opt[k].padStart(ret[1].length, \"0\")))\r\n                }\r\n            }\r\n            return fmt;\r\n        }\r\n        /**\r\n         * 获取当前时间\r\n         * @param {string} fmt 可选 时间格式 默认YYYY-MM-DD hh:mm:ss\r\n         * 获取当前年月日 YYYY-MM-DD\r\n         * 获取当前时分秒 hh:mm:ss\r\n         * @returns {String} /2016-01-01 23:59:59/\r\n         */\r\n        this.getCurrentFmtDate = function (fmt) {\r\n            var date = new Date();\r\n            return self.formatDate(date, fmt);\r\n        }\r\n        /**\r\n         * 获取指日期增加(减少)年/月/日/时/分/秒 之后的时间\r\n         * @param {string} dateStr 指定时间\r\n         * @param {number} number 需要增加或减少的数值 正数指定时间增加 负数初始时间减少 \r\n         * @param {string} type 需要增加(减少)的时间类型 years/months/days/hours/minutes/seconds\r\n         * @param {string} fmt 可选 时间格式 默认YYYY-MM-DD hh:mm:ss\r\n         */\r\n        this.dateAddNum = function (dateStr, type, number, fmt) {\r\n            var tempDate = new Date(dateStr); // 把日期字符串转换成日期格式\r\n            if (!xueUtilLang.isDate(tempDate)) {\r\n                return \"Invalid Date\";\r\n            }\r\n            switch (type) {\r\n                case \"years\":\r\n                    tempDate.setFullYear(tempDate.getFullYear() + number);\r\n                    break;\r\n                case \"months\":\r\n                    tempDate.setMonth(tempDate.getMonth() + number);\r\n                    break;\r\n                case \"days\":\r\n                    tempDate.setDate(tempDate.getDate() + number);\r\n                    break;\r\n                case \"hours\":\r\n                    tempDate.setHours(tempDate.getHours() + number);\r\n                    break;\r\n                case \"minutes\":\r\n                    tempDate.setMinutes(tempDate.getMinutes() + number);\r\n                    break;\r\n                case \"seconds\":\r\n                    tempDate.setSeconds(tempDate.getSeconds() + number);\r\n                    break;\r\n            }\r\n            return self.formatDate(tempDate, fmt);\r\n        }\r\n        /**\r\n         * 返回距 1970 年 1 月 1 日之间的毫秒数(可用于比较时间先后)\r\n         * @param {} Date 格式为：yyyy-mm-dd\r\n         */\r\n        this.formatTimesFromDate = function(Date){\r\n            var arr = Date.split(\"-\");\r\n            var newDate = new Date(arr[0],arr[1],arr[2]);\r\n            var resultDate = newDate.getTime();\r\n            return resultDate;\r\n        }\r\n        /**\r\n         * 返回距 1970 年 1 月 1 日之间的毫秒数(可用于比较时间先后)\r\n         * @param {} Time 格式为：hh:mm:ss\r\n         */\r\n        this.formatTimesFromTime = function(Time){\r\n            var arr = Time.split(\":\");\r\n            var newTime = new Date('','','',arr[0],arr[1],arr[2]);\r\n            var resultDate = newTime.getTime();\r\n            return resultDate;\r\n        }\r\n        /**\r\n         * 返回距 1970 年 1 月 1 日之间的毫秒数(可用于比较时间先后)\r\n         * @param {} DateTime 格式为：yyyy-mm-dd hh:mm:ss\r\n         */\r\n        this.formatTimesFromDateTime = function(DateTime){\r\n            var date = new Date(Date.parse(DateTime.replace(/-/g, \"/\")));\r\n            var resultDate = date.getTime();\r\n            return resultDate;\r\n        }\r\n    }\r\n]);","src/util/function.js":"angular.module('xue.util.function', ['xue.util.lang'])\r\n    .service('xueUtilFunc', [\"xueUtilLang\", function (xueUtilLang) {\r\n        var self = this;\r\n        var FUNC_ERROR_TEXT = 'Expected a function';\r\n        var nativeMax = Math.max,\r\n            nativeMin = Math.min;\r\n        /**\r\n         * 创建一个调用func的函数，通过this绑定和创建函数的参数调用func，\r\n         * 调用次数不超过 n 次。 之后再调用这个函数，将返回一次最后调用func的结果。\r\n         *\r\n         * @param {number} n 超过多少次不再调用func（限制调用func 的次数）\r\n         * @param {Function} func 限制执行的函数.\r\n         * @returns {Function} 返回新的限定函数.\r\n         */\r\n        this.before = function (n, func) {\r\n            var result;\r\n            if (typeof func !== 'function') {\r\n                throw new TypeError(FUNC_ERROR_TEXT);\r\n            }\r\n            n = parseInt(n, 0);\r\n            return function () {\r\n                if (--n >= 0) {\r\n                    result = func.apply(this, arguments);\r\n                }\r\n                if (n < 1) {\r\n                    func = undefined;\r\n                }\r\n                return result;\r\n            };\r\n        };\r\n        /**\r\n         * before的反向函数;此方法创建一个函数，当他被调用n或更多次之后将马上触发func\r\n         * \r\n         * @param {number} n 方法应该在调用多少次后才执行.\r\n         * @param {Function} func 用来限定的函数.\r\n         * @returns {Function} 返回新的限定函数.\r\n         */\r\n        this.after = function (n, func) {\r\n            if (typeof func !== 'function') {\r\n                throw new TypeError(FUNC_ERROR_TEXT);\r\n            }\r\n            n = parseInt(n, 0);\r\n            return function () {\r\n                if (--n < 1) {\r\n                    return func.apply(this, arguments);\r\n                }\r\n            };\r\n        };\r\n        /**\r\n         * 创建一个 debounced（防抖动）函数，该函数会从上一次被调用后，延迟 wait 毫秒后调用 func 方法。\r\n         *  debounced（防抖动）函数提供一个 cancel 方法取消延迟的函数调用以及 flush 方法立即调用。\r\n         *  可以提供一个 options（选项） 对象决定如何调用 func 方法，options.leading 与|或 options.trailing \r\n         * 决定延迟前后如何触发（是 先调用后等待 还是 先等待后调用）。 \r\n         * func 调用时会传入最后一次提供给 debounced（防抖动）函数 的参数。 \r\n         * 后续调用的 debounced（防抖动）函数返回是最后一次 func 调用的结果\r\n         *\r\n         * 注意: 如果 leading 和 trailing 选项为 true, 则 func 允许 trailing 方式调用的条件为: \r\n         * 在 wait 期间多次调用防抖方法。如果 wait 为 0 并且 leading 为 false, func调用将被推迟到下一个点，\r\n         * 类似setTimeout为0的超时。\r\n         *\r\n         * @param {Function} func 要防抖动的函数.\r\n         * @param {number} [wait=0] 需要延迟的毫秒数.\r\n         * @param {Object} [options={}] 选项对象.\r\n         * @param {boolean} [options.leading=false] 指定在延迟开始前调用\r\n         * @param {number} [options.maxWait] 设置 func 允许被延迟的最大值\r\n         * @param {boolean} [options.trailing=true] 指定在延迟结束后调用\r\n         * @returns {Function} 返回新的 debounced（防抖动）函数.\r\n         */\r\n        /*eslint complexity: [\"error\", 7]*/\r\n        this.debounce = function (func, wait, options) {\r\n            var lastArgs,\r\n                lastThis,\r\n                maxWait,\r\n                result,\r\n                timerId,\r\n                lastCallTime,\r\n                lastInvokeTime = 0,\r\n                leading = false,\r\n                maxing = false,\r\n                trailing = true;\r\n\r\n            if (typeof func !== 'function') {\r\n                throw new TypeError(FUNC_ERROR_TEXT);\r\n            }\r\n            wait = Number(wait) || 0;\r\n            if (xueUtilLang.isObject(options)) {\r\n                leading = !!options.leading;\r\n                maxing = 'maxWait' in options;\r\n                maxWait = maxing ? nativeMax(Number(options.maxWait) || 0, wait) : maxWait;\r\n                trailing = 'trailing' in options ? !!options.trailing : trailing;\r\n            }\r\n\r\n            function invokeFunc(time) {\r\n                var args = lastArgs,\r\n                    thisArg = lastThis;\r\n\r\n                lastArgs = lastThis = undefined;\r\n                lastInvokeTime = time;\r\n                result = func.apply(thisArg, args);\r\n                return result;\r\n            }\r\n\r\n            function leadingEdge(time) {\r\n                // Reset any `maxWait` timer.\r\n                lastInvokeTime = time;\r\n                // Start the timer for the trailing edge.\r\n                timerId = setTimeout(timerExpired, wait);\r\n                // Invoke the leading edge.\r\n                return leading ? invokeFunc(time) : result;\r\n            }\r\n\r\n            function remainingWait(time) {\r\n                var timeSinceLastCall = time - lastCallTime,\r\n                    timeSinceLastInvoke = time - lastInvokeTime,\r\n                    timeWaiting = wait - timeSinceLastCall;\r\n\r\n                return maxing ?\r\n                    nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) :\r\n                    timeWaiting;\r\n            }\r\n\r\n            function shouldInvoke(time) {\r\n                var timeSinceLastCall = time - lastCallTime,\r\n                    timeSinceLastInvoke = time - lastInvokeTime;\r\n\r\n                // Either this is the first call, activity has stopped and we're at the\r\n                // trailing edge, the system time has gone backwards and we're treating\r\n                // it as the trailing edge, or we've hit the `maxWait` limit.\r\n                return lastCallTime === undefined || timeSinceLastCall >= wait ||\r\n                    timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\r\n            }\r\n\r\n            function timerExpired() {\r\n                var time = Date.now();\r\n                if (shouldInvoke(time)) {\r\n                    return trailingEdge(time);\r\n                }\r\n                // Restart the timer.\r\n                timerId = setTimeout(timerExpired, remainingWait(time));\r\n            }\r\n\r\n            function trailingEdge(time) {\r\n                timerId = undefined;\r\n\r\n                // Only invoke if we have `lastArgs` which means `func` has been\r\n                // debounced at least once.\r\n                if (trailing && lastArgs) {\r\n                    return invokeFunc(time);\r\n                }\r\n                lastArgs = lastThis = undefined;\r\n                return result;\r\n            }\r\n\r\n            function cancel() {\r\n                if (timerId !== undefined) {\r\n                    clearTimeout(timerId);\r\n                }\r\n                lastInvokeTime = 0;\r\n                lastArgs = lastCallTime = lastThis = timerId = undefined;\r\n            }\r\n\r\n            function flush() {\r\n                return timerId === undefined ? result : trailingEdge(Date.now());\r\n            }\r\n\r\n            function debounced() {\r\n                var time = Date.now(),\r\n                    isInvoking = shouldInvoke(time);\r\n\r\n                lastArgs = arguments;\r\n                lastThis = this;\r\n                lastCallTime = time;\r\n\r\n                if (isInvoking) {\r\n                    if (timerId === undefined) {\r\n                        return leadingEdge(lastCallTime);\r\n                    }\r\n                    if (maxing) {\r\n                        // Handle invocations in a tight loop.\r\n                        clearTimeout(timerId);\r\n                        timerId = setTimeout(timerExpired, wait);\r\n                        return invokeFunc(lastCallTime);\r\n                    }\r\n                }\r\n                if (timerId === undefined) {\r\n                    timerId = setTimeout(timerExpired, wait);\r\n                }\r\n                return result;\r\n            }\r\n            debounced.cancel = cancel;\r\n            debounced.flush = flush;\r\n            return debounced;\r\n        };\r\n\r\n        /**\r\n         * “delay”和“defer”的基本实现，接受“args”\r\n         *\r\n         * @private\r\n         * @param {Function} func 延迟加载的函数.\r\n         * @param {number} wait 延迟秒数.\r\n         * @param {Array} args 提供给func的参数.\r\n         * @returns {number|Object} 返回计时器id或timeout对象 \r\n         */\r\n        this._baseDelay = function (func, wait, args) {\r\n            if (typeof func !== 'function') {\r\n                throw new TypeError(FUNC_ERROR_TEXT);\r\n            }\r\n            return setTimeout(function () {\r\n                func.apply(undefined, args);\r\n            }, wait);\r\n        };\r\n        /**\r\n         * 推迟调用func，直到当前堆栈清理完毕。 调用时，任何附加\r\n         * \r\n         * @param {Function} func 要延迟的函数.\r\n         * @param {...*} [args] 会在调用时传给 func 的参数.\r\n         * @returns {number} 返回计时器 id.\r\n         */\r\n        this.defer = function (func, args) {\r\n            return self._baseDelay(func, 1, args);\r\n        };\r\n        /**\r\n         * 延迟 wait 毫秒后调用 func。 调用时，任何附加的参数会传给func\r\n         *\r\n         * @param {Function} func 要延迟的函数.\r\n         * @param {number} wait 要延迟的毫秒数.\r\n         * @param {...*} [args] 会在调用时传入到func的参数.\r\n         * @returns {number} 返回计时器id.\r\n         */\r\n        this.delay = function (func, wait, args) {\r\n            return self._baseDelay(func, Number(wait) || 0, args);\r\n        };\r\n        /**\r\n         * 创建一个只能调用 func 一次的函数。 重复调用返回第一次调用的结果。 \r\n         * func 调用时， this 绑定到创建的函数，并传入对应参数。\r\n         *\r\n         * @param {Function} func 指定的触发的函数.\r\n         * @returns {Function} 返回新的受限函数.\r\n         */\r\n        this.once = function (func) {\r\n            return self.before(1, func);\r\n        };\r\n        /**\r\n         * 创建一个函数，调用func时，this绑定到创建的新函数，把参数作为数组传入，类似于 Function#apply\r\n         *\r\n         * @param {Function} func 要应用传播参数的函数.\r\n         * @param {number} [start=0] spread 参数的开始位置.\r\n         * @returns {Function} 返回新的函数.\r\n         */\r\n        this.spread = function (func, start) {\r\n            if (typeof func !== 'function') {\r\n                throw new TypeError(FUNC_ERROR_TEXT);\r\n            }\r\n            start = !start ? 0 : nativeMax(parseInt(start, 0), 0);\r\n            return function () {\r\n                var args = Array.prototype.slice.call(arguments);\r\n                var array = args[start],\r\n                    otherArgs = args.slice(0, start);\r\n\r\n                if (array) {\r\n                    otherArgs = otherArgs.concat(array);\r\n                }\r\n                return func.apply(this, otherArgs);\r\n            };\r\n        };\r\n        /**\r\n         * 创建一个调用func的函数，thisArg绑定func函数中的 this (this的上下文为thisArg) ，\r\n         * 并且func函数会接收partials附加参数。\r\n         * \r\n         * @param {Function} func 绑定的函数.\r\n         * @param {*} thisArg 绑定的this对象.\r\n         * @param {...*} [partials] 附加的部分参数.\r\n         * @returns {Function} 返回新的绑定函数.\r\n         */\r\n        this.bind = function (func, thisArg) {\r\n            if (typeof func !== 'function') {\r\n                throw new TypeError(FUNC_ERROR_TEXT);\r\n            }\r\n            var outerArgs = Array.prototype.slice.call(arguments, 2);\r\n            //此处的arguments为调用此函数时传进来的参数；2代表只需要保存第二个参数之后的其他的参数\r\n            return function () { //返回值应该是一个函数\r\n                var innerArgs = Array.prototype.slice.call(arguments);\r\n                //此处的arguments为内部函数的参数\r\n                var finalArgs = outerArgs.concat(innerArgs);\r\n                return func.apply(thisArg, finalArgs); //使用apply方法来改变this的指向\r\n            };\r\n        };\r\n    }]);","src/util/lang.js":"angular.module(\"xue.util.lang\", []).service(\"xueUtilLang\", [\r\n    function() {\r\n        var self = this;\r\n        /** 对象类型 */\r\n        var objType = [\"Null\", \"Undefined\", \"Number\", \"Boolean\", \"String\", \"Object\", \"Function\", \"Array\", \"RegExp\", \"Date\"];\r\n\r\n        /**\r\n         * 判断是否为对象\r\n         *\r\n         * @param {any} obj\r\n         * @returns {boolean}\r\n         */\r\n        this.isObject = function(obj) {\r\n            var type = typeof obj;\r\n            return obj !== null && (type === \"object\" || type === \"function\");\r\n        };\r\n        /**\r\n         * 判断是否为函数\r\n         *\r\n         * @param {any} fn\r\n         * @returns {boolean}\r\n         */\r\n        this.isFunction = function(fn) {\r\n            return Object.prototype.toString.call(fn) === \"[object Function]\";\r\n        };\r\n        /**\r\n         * 判断是否为Json\r\n         * @param {any} json\r\n         * @returns {boolean}\r\n         */\r\n        this.isJson = function (json) {\r\n            return Object.prototype.toString.call(json) === \"[object Object]\";\r\n        };\r\n        /**\r\n         * 检查是否是原始Number数值型或者Number对象。\r\n         *\r\n         * @param {any} number\r\n         * @returns {boolean}\r\n         */\r\n        this.isNumber = function(number) {\r\n            return typeof number === 'number' || Object.prototype.toString.call(number) === \"[object Number]\";\r\n        };\r\n        /**\r\n         * 判断是否为Date对象\r\n         * @param {any} date\r\n         * @returns {boolean}\r\n         */\r\n        this.isDate = function(date) {\r\n            return date instanceof Date || Object.prototype.toString.call(date) === \"[object Date]\";\r\n        };\r\n        /**\r\n         * 判断是否为图片\r\n         * \r\n         * @param {any} path\r\n         * @returns {boolean}\r\n         */\r\n        this.isPicture = function (path) {\r\n            var fileReg = /(.*).(jpg|bmp|gif|ico|pcx|jpeg|tif|png|raw|tga)$/i;\r\n            try {\r\n                return fileReg.test(path);\r\n            } catch (e) {\r\n                return false;\r\n            }\r\n        };\r\n        /**\r\n         * 判断是否为空对象\r\n         *\r\n         * @param {any} obj\r\n         * @returns {boolean}\r\n         */\r\n        this.isObjectEmpty = function(obj) {\r\n            if (Object.getOwnPropertyNames) {\r\n                return (Object.getOwnPropertyNames(obj).length === 0);\r\n            } else {\r\n                var k;\r\n                for (k in obj) {\r\n                    if (Object.prototype.hasOwnProperty.call(k, obj)) {\r\n                        return false;\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n        };\r\n        /**\r\n         * 判断对象类型\r\n         *\r\n         * @param {any} obj 对象object\r\n         * @param {any} type 对象类型\r\n         * @returns {boolean}\r\n         */\r\n        this.isType = function(obj, type) {\r\n            return this.getType(obj) === type;\r\n        };\r\n        /**\r\n         * 获取对象类型\r\n         *\r\n         * @param {any} obj 对象object\r\n         * @returns {string}\r\n         */\r\n        this.getType = function(obj) {\r\n            var map = {};\r\n            angular.forEach(objType, function(item) {\r\n                map[\"[object \" + item + \"]\"] = item.toLowerCase();\r\n            });\r\n            return map[Object.prototype.toString.call(obj)] || \"object\";\r\n        };\r\n        /**\r\n         * 复制对象\r\n         *\r\n         * @param {any} obj\r\n         * @param {any} deep 是否深度复制\r\n         * @returns {object}\r\n         */\r\n        this.copyObj = function(obj, deep) {\r\n            if (!self.isObject(obj)) {\r\n                return obj;\r\n            }\r\n            var i, target = self.isType(obj, \"array\") ? [] : {}, value, valueType;\r\n            for (i in obj) {\r\n                if (hasOwnProperty.call(obj, i)) {\r\n                    value = obj[i];\r\n                    valueType = self.getType(value);\r\n                    if (deep && (valueType === \"array\" || valueType === \"object\")) {\r\n                        target[i] = self.copyObj(value, deep);\r\n                    } else {\r\n                        target[i] = value;\r\n                    }\r\n                }\r\n            }\r\n            return target;\r\n        };\r\n        /**\r\n         * 匹配对象\r\n         * 检查对象是否包含要匹配的对象\r\n         *\r\n         * @param {any} obj 要检查的对象\r\n         * @param {any} source 要匹配的对象\r\n         * @returns {boolean}\r\n         */\r\n        this.isMatch = function(obj, source) {\r\n            if (!self.isObject(obj) || !self.isObject(source)) {\r\n                return false;\r\n            }\r\n            if (obj === source) {\r\n                return true;\r\n            }\r\n            var matchKeyArr = [], matchLen;\r\n            for (var k in Object(source)) {\r\n                if (hasOwnProperty.call(source, k)) {\r\n                    matchKeyArr.push(k);\r\n                }\r\n            }\r\n            matchLen = matchKeyArr.length;\r\n\r\n            while (matchLen--) {\r\n                var key = matchKeyArr[matchLen],\r\n                    value = source[key],\r\n                    childObj = self.isObject(value);\r\n                if (!obj[key]) {\r\n                    return false;\r\n                } \r\n                if (!childObj) {\r\n                    if (value !== obj[key]) {\r\n                        return false;\r\n                    }\r\n                } else {\r\n                    if (!self.isMatch(obj[key], value)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n        /**\r\n         * 判断是否为IE\r\n         */\r\n        this.isIE = function () {\r\n            return !!window.ActiveXObject || \"ActiveXObject\" in window;\r\n        };\r\n        /**\r\n         * 判断是否为IE8\r\n         */\r\n        this.isIE8 = function () {\r\n            var a = navigator.appVersion.split(\";\"), b;\r\n            //系统是32位时谷歌浏览器版本号没有';',长度为1,a[1]为undefined,replace方法报错\r\n            if (a.length > 1) {\r\n                b = a[1].replace(/[ ]/g, \"\");\r\n            } else {\r\n                return false;\r\n            }\r\n            return navigator.appName === \"Microsoft Internet Explorer\" && b === \"MSIE8.0\";\r\n        };\r\n    }\r\n]);\r\n","src/util/math.js":"angular.module(\"xue.util.math\", ['xue.util.lang'])\r\n    .service(\"xueUtilMath\", [\"xueUtilLang\", function(xueUtilLang) {\r\n        var self = this;\r\n        /**\r\n         * 加法（解决浮点精度问题）\r\n         * @param {number} number1 数值1\r\n         * @param {number} number2 数值2\r\n         */\r\n        this.addition = function(number1, number2) {\r\n            var decimalLen1, decimalLen2, maxLenPower;\r\n            try {\r\n                decimalLen1 = number1.toString().split(\".\")[1].length;\r\n            } catch (e) {\r\n                decimalLen1 = 0;\r\n            }\r\n            try {\r\n                decimalLen2 = number2.toString().split(\".\")[1].length;\r\n            } catch (e) {\r\n                decimalLen2 = 0;\r\n            }\r\n            maxLenPower = Math.pow(10, Math.max(decimalLen1, decimalLen2));\r\n            return (number1 * maxLenPower + number2 * maxLenPower) / maxLenPower;\r\n        };\r\n        /**\r\n         * 减法（解决浮点精度问题）\r\n         * @param {number} subtrahend 减数\r\n         * @param {number} minuend 被减数\r\n         */\r\n        this.subtraction = function(subtrahend, minuend) {\r\n            var decimalLen1, decimalLen2, maxLenPower, maxLen;\r\n            try {\r\n                decimalLen1 = subtrahend.toString().split(\".\")[1].length;\r\n            } catch (e) {\r\n                decimalLen1 = 0;\r\n            }\r\n            try {\r\n                decimalLen2 = minuend.toString().split(\".\")[1].length;\r\n            } catch (e) {\r\n                decimalLen2 = 0;\r\n            }\r\n            maxLen = Math.max(decimalLen1, decimalLen2);\r\n            maxLenPower = Math.pow(10, maxLen);\r\n            return Number(\r\n                ((subtrahend * maxLenPower - minuend * maxLenPower) / maxLenPower).toFixed(maxLen)\r\n            );\r\n        };\r\n        /**\r\n         * 乘法（解决浮点精度问题）\r\n         * @param {number} multiplier1 乘数1\r\n         * @param {number} multiplier2 乘数2\r\n         */\r\n        this.multiplication = function(multiplier1, multiplier2) {\r\n            var decimalLen = 0;\r\n            multiplier1 = multiplier1.toString();\r\n            multiplier2 = multiplier2.toString();\r\n            try {\r\n                decimalLen += multiplier1.split(\".\")[1].length;\r\n            } catch (e) {\r\n                decimalLen += 0;\r\n            }\r\n            try {\r\n                decimalLen += multiplier2.split(\".\")[1].length;\r\n            } catch (e) {\r\n                decimalLen += 0;\r\n            }\r\n            return Number(multiplier1.replace(\".\", \"\")) * Number(multiplier2.replace(\".\", \"\") /\r\n                Math.pow(10, decimalLen)\r\n            );\r\n        };\r\n        /**\r\n         * 除法（解决浮点精度问题）\r\n         * @param {number} divisor 除数\r\n         * @param {number} dividend 被除数\r\n         */\r\n        this.division = function(divisor, dividend) {\r\n            var decimalLen1, decimalLen2, nDivisor, nDividend;\r\n            try {\r\n                decimalLen1 = divisor.toString().split(\".\")[1].length;\r\n            } catch (e) {\r\n                decimalLen1 = 0;\r\n            }\r\n            try {\r\n                decimalLen2 = dividend.toString().split(\".\")[1].length;\r\n            } catch (e) {\r\n                decimalLen2 = 0;\r\n            }\r\n            nDivisor = Number(divisor.toString().replace(\".\", \"\"));\r\n            nDividend = Number(dividend.toString().replace(\".\", \"\"));\r\n            return this.multiplication(\r\n                nDivisor / nDividend,\r\n                Math.pow(10, decimalLen2 - decimalLen1)\r\n            );\r\n        };\r\n        /**\r\n         * 平均值（解决浮点精度问题）\r\n         * @param {arr} arr 要迭代的数组\r\n         */\r\n        this.mean = function(arr) {\r\n            if (!Array.isArray(arr) || !arr.length) {\r\n                return NaN;\r\n            }\r\n            var result, index = -1, length = arr.length;\r\n            while (++index < length) {\r\n                var current = arr[index];\r\n                if (current !== undefined) {\r\n                    result = result === undefined ? current : self.addition(result, current);\r\n                }\r\n            }\r\n            return result / length;\r\n        };\r\n        /**\r\n         * 获取数组最大值（解决浮点精度问题）\r\n         * @param {arr} arr 要迭代的数组\r\n         */\r\n        this.max = function(arr) {\r\n            if (!Array.isArray(arr) || !arr.length) {\r\n                return undefined;\r\n            }\r\n            var max = arr.reduce(function(a, b) {\r\n                if (!xueUtilLang.isNumber(a)) {\r\n                    return b;\r\n                } else if (!xueUtilLang.isNumber(b)) {\r\n                    return a;\r\n                }\r\n                if (self.subtraction(a, b) > 0) {\r\n                    return a;\r\n                } else {\r\n                    return b;\r\n                }\r\n            })\r\n            if (!xueUtilLang.isNumber(max)) {\r\n                return undefined;\r\n            }\r\n            return max;\r\n        };\r\n         /**\r\n         * 获取数组最小值（解决浮点精度问题）\r\n         * @param {arr} arr 要迭代的数组\r\n         */\r\n        this.min = function(arr) {\r\n            if (!Array.isArray(arr) || !arr.length) {\r\n                return undefined;\r\n            }\r\n            var min = arr.reduce(function(a, b) {\r\n                if (!xueUtilLang.isNumber(a)) {\r\n                    return b;\r\n                } else if (!xueUtilLang.isNumber(b)) {\r\n                    return a;\r\n                }\r\n                if (self.subtraction(a, b) < 0) {\r\n                    return a;\r\n                } else {\r\n                    return b;\r\n                }\r\n            })\r\n            if (!xueUtilLang.isNumber(min)) {\r\n                return undefined;\r\n            }\r\n            return min;\r\n        };\r\n         /**\r\n         * 数字根据精度四舍五入\r\n         * @param {number} number 要四舍五入的数字(包含科学计数法)\r\n         * @param {arr} precision 四舍五入的精度(负数表示整数位四舍五入取整)\r\n         */\r\n        this.round = function(number, precision) {\r\n            if (!xueUtilLang.isNumber(number)) {\r\n                return NaN;\r\n            } else if (!precision) {\r\n                return Math.round(number)\r\n            } else {\r\n                var pair = (number.toString() + 'e').split('e'),\r\n                value = Math.round(pair[0] + 'e' + (+pair[1] + precision));\r\n                pair = (value.toString() + 'e').split('e');\r\n                return +(pair[0] + 'e' + (+pair[1] - precision));\r\n            }\r\n        };\r\n    }\r\n]);\r\n","src/util/methods.js":"angular.module('xue.util.methods', [])\r\n    .service('xueUtilMethod', [function () {\r\n\r\n    }]);","src/util/number.js":"angular.module('xue.util.number', [])\r\n    .service('xueUtilNumber', [function () {\r\n        /**\r\n         * 检查 n 是否在 start 与 end 之间，但不包括 end。\r\n         * 如果 end 没有指定，那么 start 设置为0。 \r\n         * 如果 start 大于 end，那么参数会交换以便支持负范围。\r\n         *\r\n         * @param {number} number  要检查的值\r\n         * @param {number} start   开始范围\r\n         * @param {number} end     结束范围\r\n         * @returns\r\n         */\r\n        this.inRange = function (number, start, end) {\r\n            if (end === undefined) {\r\n                end = start;\r\n                start = 0;\r\n            }\r\n            return number >= Math.min(start, end) && number < Math.max(start, end);\r\n        };\r\n        /**\r\n         * 产生一个包括 lower 与 upper 之间的数。\r\n         * 如果只提供一个参数返回一个0到提供数之间的数。 \r\n         * 如果 floating 设为 true，或者 lower 或 upper 是浮点数，结果返回浮点数。\r\n         *\r\n         * @param {number}  lower     要检查的值\r\n         * @param {number}  upper     开始范围\r\n         * @param {boolean} floating  结束范围\r\n         * @returns\r\n         */\r\n        /*eslint complexity: [\"error\", { \"max\": 12 }]*/\r\n        this.random = function (lower, upper, floating) {\r\n            var INFINITY = 1 / 0,\r\n                MAX_INTEGER = Number.MAX_VALUE || 1.7976931348623157e308;\r\n\r\n            if (floating === undefined) {\r\n                if (typeof upper === \"boolean\") {\r\n                    floating = upper;\r\n                    upper = undefined;\r\n                } else if (typeof lower === \"boolean\") {\r\n                    floating = lower;\r\n                    lower = undefined;\r\n                }\r\n            }\r\n            if (lower === undefined && upper === undefined) {\r\n                lower = 0;\r\n                upper = 1;\r\n            } else {\r\n                lower = toFinite(lower);\r\n                if (upper === undefined) {\r\n                    upper = lower;\r\n                    lower = 0;\r\n                } else {\r\n                    upper = toFinite(upper);\r\n                }\r\n            }\r\n            if (lower > upper) {\r\n                var temp = lower;\r\n                lower = upper;\r\n                upper = temp;\r\n            }\r\n            if (floating || lower % 1 || upper % 1) {\r\n                return Math.min(\r\n                    lower +\r\n                    Math.random() *\r\n                    (upper -\r\n                        lower +\r\n                        Number.parseFloat(\"1e-\" + ((Math.random() + \"\").length - 1))),\r\n                    upper\r\n                );\r\n            }\r\n            return lower + Math.floor(Math.random() * (upper - lower + 1));\r\n\r\n            function toFinite(value) {\r\n                if (!value) {\r\n                    return value === 0 ? value : 0;\r\n                }\r\n                value = toNumber(value);\r\n                if (value === INFINITY || value === -INFINITY) {\r\n                    var sign = value < 0 ? -1 : 1;\r\n                    return sign * MAX_INTEGER;\r\n                }\r\n                return isNaN(value) ? 0 : value;\r\n            }\r\n\r\n            function isNaN(value) {\r\n                return isNumber(value) && value !== +value;\r\n            }\r\n\r\n            function isNumber(value) {\r\n                return typeof value === 'number' ||\r\n                    isObjectLike(value) && Object.prototype.toString.call(value) === '[object Number]';\r\n            }\r\n        };\r\n        /**\r\n         * 确认所给值只在min,max之间\r\n         * 如果所给值是在min,max之间，那么就直接返回该值\r\n         * 否则返回与所给值最接近的min值或max值\r\n         *\r\n         * @param {number}  number  被限制的值\r\n         * @param {number}  lower   下限\r\n         * @param {number}  upper   上限\r\n         * @returns\r\n         */\r\n        this.clamp = function (number, lower, upper) {\r\n            if (upper === undefined) {\r\n                upper = lower;\r\n                lower = undefined;\r\n            }\r\n            if (upper !== undefined) {\r\n                upper = toNumber(upper);\r\n                upper = isNaN(upper) ? 0 : upper;\r\n            }\r\n            if (lower !== undefined) {\r\n                lower = toNumber(lower);\r\n                lower = isNaN(lower) ? 0 : lower;\r\n            }\r\n            return baseClamp(toNumber(number), lower, upper);\r\n\r\n            function baseClamp(number, lower, upper) {\r\n                if (!isNaN(number)) {\r\n                    if (upper !== undefined) {\r\n                        number = number <= upper ? number : upper;\r\n                    }\r\n                    if (lower !== undefined) {\r\n                        number = number >= lower ? number : lower;\r\n                    }\r\n                }\r\n                return number;\r\n            }\r\n        };\r\n\r\n        function toNumber(value) {\r\n            if (typeof value === \"number\") {\r\n                return value;\r\n            }\r\n            if (isSymbol(value)) {\r\n                return 0 / 0;\r\n            }\r\n            return Number(value);\r\n        }\r\n\r\n        function isSymbol(value) {\r\n            return typeof value === \"symbol\" || isObjectLike(value) && Object.prototype.toString.call(value) === \"[object Symbol]\";\r\n        }\r\n\r\n        function isObjectLike(value) {\r\n            return typeof value === \"object\" && value !== null;\r\n        }\r\n\r\n    }]);","src/util/object.js":"angular.module('xue.util.object', [])\r\n    .service('xueUtilObject', [function () {\r\n        var self = this;\r\n        /**\r\n         * json中把空对象移除\r\n         *\r\n         * @param {any} json\r\n         * @returns\r\n         */\r\n        this.removeEmptyField = function (json) {\r\n            var newJson = {};\r\n            for (var key in json) {\r\n                if (json[key]) {\r\n                    newJson[key] = json[key];\r\n                }\r\n            }\r\n            return newJson;\r\n        };\r\n        /**\r\n         * json中把数组的对象中的空属性移除\r\n         *\r\n         * @param {any} json\r\n         * @returns\r\n         */\r\n        this.removeEmptyParams = function (array) {\r\n            var newArray = [];\r\n            for (var i = 0, len = array.length; i < len; i++) {\r\n                var newObj = {};\r\n                for (var j in array[i]) {\r\n                    if (array[i][j]) {\r\n                        newObj[j] = array[i][j];\r\n                    }\r\n                }\r\n                newArray.push(newObj);\r\n            }\r\n            return newArray;\r\n        };\r\n        /**\r\n         * 判断两个对象值是否相等(仅用于参数是对象的情况)\r\n         *\r\n         * @param {object} objA   \r\n         * @param {object} objB\r\n         * @returns 成功true，失败false\r\n         */\r\n        /*eslint complexity: [\"error\", { \"max\": 8 }]*/\r\n        this.isObjectValueEqual = function (objA, objB) {\r\n            if (typeof objA !== \"object\" || typeof objB !== \"object\") {\r\n                return false;\r\n            }\r\n            var aProps = Object.getOwnPropertyNames(objA);\r\n            var bProps = Object.getOwnPropertyNames(objB);\r\n            if (aProps.length !== bProps.length) {\r\n                return false;\r\n            }\r\n            for (var i = 0, len = aProps.length; i < len; i++) {\r\n                var propName = aProps[i];\r\n                var propA = objA[propName];\r\n                var propB = objB[propName];\r\n                if (typeof propA === 'object') {\r\n                    if (self.isObjectValueEqual(propA, propB)) {\r\n                        return true;\r\n                    }\r\n                    return false;\r\n                } else if (propA !== propB) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n        /**\r\n         * 根据value找到对象的key路径值\r\n         *\r\n         * @param {object} obj   \r\n         * @param {any}    value\r\n         * @returns 成功返回的是路径数组，失败则是undefined\r\n         */\r\n        this.searchKeys = function (obj, value) {\r\n            for (var key in obj) {\r\n                if (obj[key]) {\r\n                    if (obj[key] === value || self.isObjectValueEqual(obj[key], value)) {\r\n                        return key.split(\",\");\r\n                    }\r\n                    if (typeof obj[key] === 'object') {\r\n                        var temp = self.searchKeys(obj[key], value);\r\n                        if (temp) {\r\n                            return (key + \",\" + temp).split(\",\");\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        /**\r\n         * 根据key路径找到对象的value值\r\n         *\r\n         * @param {object} obj  \r\n         * @param {array}  pathArr \r\n         * @param {number} index   一般不用传（默认为0）\r\n         * @returns 成功返回的是value，失败则是undefined\r\n         */\r\n        this.findValByPath = function (obj, pathArr, index) {\r\n            if (typeof obj !== \"object\" || Object.prototype.toString.call(pathArr) !== '[object Array]') {\r\n                throw new Error(\"参数有误\");\r\n            }\r\n            if (!pathArr.length) {\r\n                return obj;\r\n            }\r\n            index = index || 0;\r\n            if (index >= pathArr.length - 1) {\r\n                return obj[pathArr[index]];\r\n            }\r\n            return self.findValByPath(obj[pathArr[index]], pathArr, ++index);\r\n        };\r\n        /**\r\n         * object键值对换(如果 object 有重复的值，后面的值会覆盖前面的值)\r\n         *\r\n         * @param {object} obj\r\n         * @returns newObj 返回新的键值对换后的对象\r\n         */\r\n        this.reverseObject = function (obj) {\r\n            var newObj = {};\r\n            for (var key in obj) {\r\n                newObj[obj[key]] = key;\r\n            }\r\n            return newObj;\r\n        }\r\n    }]);","src/util/properties.js":"angular.module('xue.util.properties', [])\r\n    .service('xueUtilProperty', [function () {\r\n\r\n    }]);","src/util/seq.js":"angular.module('xue.util.seq', [])\r\n    .service('xueUtilSeq', [function () {\r\n\r\n    }]);","src/util/string.js":"angular.module('xue.util.string', [])\r\n    .service('xueUtilString', [function () {\r\n        //var self = this;\r\n        var reg = /^[A-Za-z]+$/;\r\n        // 判断字符串是否为英文\r\n        function checkEng(num) {\r\n            return reg.test(num);\r\n        }\r\n        function replaceEndIndex(string) {\r\n            for (var i = string.length - 1; i >= 0; i--) {\r\n                if (/[A-Za-z0-9]+/.test(string[i])) {\r\n                    return i;\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n        function replaceStratIndex(string) {\r\n            for (var i = 0; i < string.length; i++) {\r\n                if (/[A-Za-z0-9]+/.test(string[i])) {\r\n                    return i;\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n        function lowerCaseHandle(string) {\r\n            var arr = [];\r\n            var index = 0;\r\n            for (var i = 1; i < string.length; i++) {\r\n                if (/[A-Z]+/.test(string[i]) && /[a-z]+/.test(string[i - 1])) {\r\n                    arr.push(string.slice(index, i));\r\n                    index = i;\r\n                }\r\n            }\r\n            arr.push(string.slice(index, string.length));\r\n            return arr;\r\n        }\r\n        /**\r\n         * 转换字符串string首字母为大写，剩下为小写\r\n         * \r\n         * @param {any} string\r\n         * @returns\r\n         */\r\n        this.capitalize = function (string) {\r\n            var str = string ? string.toString().toLowerCase() : '';\r\n            if (str.length < 2) {\r\n                return str.charAt(0).toUpperCase();\r\n            }\r\n            return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();\r\n        };\r\n        /**\r\n         * 检查字符串string是否包含target\r\n         * \r\n         * @param {any} String\r\n         * @param {any} target //目标字符串\r\n         * @param {any} position //检查的位置\r\n         * @returns\r\n         */\r\n        this.endsWith = function (string, target, position) {\r\n            if (!string || !target) {\r\n                return false;\r\n            }\r\n            var str = string.toString();\r\n            var tar = target.toString();\r\n            var pos = position ? parseInt(position, 0) : 0;\r\n            var index = str.indexOf(tar);\r\n            if (index !== -1 && (typeof position === 'undefined' || index === pos)) {\r\n                return true;\r\n            }\r\n            return false;\r\n        };\r\n        /**\r\n         * 转换字符串string以空格分开单词\r\n         * \r\n         * @param {any} String\r\n         * @returns\r\n         * 返回一个数组\r\n         */\r\n        this.lowerCase = function (string) {\r\n            string = string.toString().replace(/[^A-Za-z]/g, ' ');\r\n            var temp = string.split(' ');\r\n            var arr = [];\r\n            for (var i = 0; i < temp.length; i++) {\r\n                if (temp[i]) {\r\n                    if (/[A-Z]+/.test(temp[i].slice(1)) && /[a-z]+/.test(temp[i].slice(1))) {\r\n                        arr = arr.concat(lowerCaseHandle(temp[i]));\r\n                    } else if (temp[i].length === 2 && /[A-Z]+/.test(temp[i].slice(1))) {\r\n                        arr.push(temp[i][0]);\r\n                        arr.push(temp[i][1]);\r\n                    } else {\r\n                        arr.push(temp[i]);\r\n                    }\r\n                }\r\n            }\r\n            return arr;\r\n        };\r\n        /**\r\n         * 字符串头部/尾部补充\r\n         * @param {any} String\r\n         * @param {any} length //填充的长度\r\n         * @param {any} type   // 填充类型\r\n         * @param {any} chars  // 填充的字符串\r\n         * padStart('ab',4,'x');->xxab\r\n         * @returns\r\n         */\r\n        this.padChars = function (string, length, type, chars) {\r\n            string = string.toString();\r\n            length = parseInt(length, 0);\r\n            chars = chars ? chars : ' ';\r\n            var newString = '';\r\n            if (type === 'start') {\r\n                newString = string.padStart(length, chars);\r\n            }\r\n            else {\r\n                newString = string.padEnd(length, chars);\r\n            }\r\n            return newString;\r\n        };\r\n        /**\r\n         * 格式化文字\r\n         *\r\n         * @param {any} text\r\n         * @param {any} len\r\n         */\r\n        this.formatterText = function (text, len) {\r\n            var newText = text.trim();\r\n            var string = '';\r\n            if (newText.length) {\r\n                var length = len || 10;\r\n                if (newText.length > length) {\r\n                    string = newText.substring(0, length) + '...';\r\n                } else {\r\n                    string = newText;\r\n                }\r\n            }\r\n            return string;\r\n        };\r\n        /**\r\n         * 格式化长文字（中间省略）\r\n         * \r\n         * @param {any} text \r\n         * @param {any} len \r\n         */\r\n        this.formatLongText = function (text, len) {\r\n            var newText = text.trim();\r\n            var string = '';\r\n            if (newText.length) {\r\n                var length = len || (parseInt(len, 0) > 0 ? parseInt(len, 0) : 5);\r\n                if (newText.length > length * 2) {\r\n                    string = newText.substring(0, length) + '...' + newText.substring(newText.length - length, newText.length);\r\n                } else {\r\n                    string = newText;\r\n                }\r\n            }\r\n            return string;\r\n        };\r\n        /**\r\n         * 获取字节长度（英文数字占1个字符，中文汉字占2个字符）\r\n         * @param {string} str \r\n         */\r\n        this.getByteLen = function (str) {\r\n            var len = 0;\r\n            try {\r\n                for (var i = 0; i < str.length; i++) {\r\n                    var c = str.charCodeAt(i);\r\n                    //单字节加1\r\n                    if (c >= 0x0001 && c <= 0x007e || c >= 0xff60 && c <= 0xff9f) {\r\n                        len++;\r\n                    } else {\r\n                        len += 2;\r\n                    }\r\n                }\r\n            } catch (e) {\r\n                len = 0;\r\n            }\r\n            return len;\r\n        };\r\n        /**\r\n        * 过滤字符串中html标签（防止ssl攻击）\r\n        * @param {string} str \r\n        */\r\n        this.filterHtml = function (str) {\r\n            var string = '';\r\n            try {\r\n                string = str.replace(/&nbsp;/ig, '').replace(/<[^<>]+>/g, '');\r\n            } catch (e) {\r\n                string = '';\r\n            }\r\n            return string;\r\n        };\r\n        /**\r\n        * 重复 N 次给定字符串\r\n        * @param {string} string \r\n        * @param {string} len\r\n        */\r\n        this.repeat = function (string, len) {\r\n            var newString = '';\r\n            len = len ? len : 0;\r\n            for (var i = 0; i < len; i++) {\r\n                newString += string;\r\n            }\r\n            return newString;\r\n        };\r\n        /**\r\n        * 根据cahr 拆分字符串string\r\n        * @param {string} string \r\n        * @param {string} char\r\n        * @param {string} len\r\n        */\r\n        this.split = function (string, char, len) {\r\n            string = string.toString();\r\n            if (!char) {\r\n                return string;\r\n            }\r\n            var temp = string.split(char);\r\n            if (!len) {\r\n                return temp;\r\n            }\r\n            if (len < temp.length) {\r\n                temp = temp.splice(0, len);\r\n            }\r\n            return temp;\r\n        };\r\n        /**\r\n        * string字符串中移除前面和后面的 空格 或 指定的字符\r\n        * @param {string} string \r\n        * @param {string} chars\r\n        */\r\n        this.replace = function (string, chars) {\r\n            string = string.toString();\r\n            chars = chars ? '[' + chars + ']' : '';\r\n            string = string.replace(new RegExp(chars, 'g'), '');\r\n            return string.trim();\r\n        };\r\n        /**\r\n        * string字符串中移除后面的空格或指定的字符\r\n        * @param {string} string \r\n        * @param {string} chars\r\n        */\r\n        this.replaceEnd = function (string, chars) {\r\n            if (!string) {\r\n                return '';\r\n            }\r\n            chars = chars ? '[' + chars + ']' : '';\r\n            var index = replaceEndIndex(string);\r\n            var newString = '';\r\n            if (index !== -1) {\r\n                var start = string.slice(0, index);\r\n                var end = string.slice(index, string.length).replace(new RegExp(chars, 'g'), '').trim();\r\n                newString = start + end;\r\n            } else {\r\n                newString = string.replace(new RegExp(chars, 'g'), '').trim();\r\n            }\r\n            return newString;\r\n        };\r\n        /**\r\n        * string字符串中移除前面的空格或指定的字符\r\n        * @param {string} string \r\n        * @param {string} chars\r\n        */\r\n        this.replaceStrat = function (string, chars) {\r\n            if (!string) {\r\n                return '';\r\n            }\r\n            chars = chars ? '[' + chars + ']' : '';\r\n            var index = replaceStratIndex(string);\r\n            var newString = '';\r\n            if (index !== -1) {\r\n                var start = string.slice(0, index).replace(new RegExp(chars, 'g'), '').trim();\r\n                var end = string.slice(index, string.length);\r\n                newString = start + end;\r\n            } else {\r\n                newString = string.replace(new RegExp(chars, 'g'), '').trim();\r\n            }\r\n            return newString;\r\n        };\r\n    }]);","src/util/util.js":"angular.module('xue.util',[\r\n    'xue.util.array','xue.util.collection','xue.util.date','xue.util.lang',\r\n    'xue.util.math','xue.util.methods','xue.util.number','xue.util.object',\r\n    'xue.util.properties','xue.util.seq','xue.util.string','xue.util.function']);","template/pagination/pager.html.js":"angular.module(\"xue/template/pagination/pager.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"xue/template/pagination/pager.html\",\n    \"<ul class=\\\"pager\\\">\\n\" +\n    \"    <li ng-class=\\\"{disabled: noPrevious(), previous: align}\\\"><a href ng-click=\\\"selectPage(page - 1)\\\">{{getText('previous')}}</a></li>\\n\" +\n    \"    <li ng-class=\\\"{disabled: noNext(), next: align}\\\"><a href ng-click=\\\"selectPage(page + 1)\\\">{{getText('next')}}</a></li>\\n\" +\n    \"</ul>\");\n}]);\n","template/pagination/pagination.html.js":"angular.module(\"xue/template/pagination/pagination.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"xue/template/pagination/pagination.html\",\n    \"<ul class=\\\"xui-pagination-wrap\\\">\\n\" +\n    \"    <li ng-if=\\\"boundaryLinks\\\" ng-class=\\\"{disabled: noPrevious()}\\\">\\n\" +\n    \"        <a href ng-click=\\\"selectPage(1)\\\">{{getText('first')}}</a>\\n\" +\n    \"    </li>\\n\" +\n    \"    <li ng-if=\\\"directionLinks\\\" ng-class=\\\"{disabled: noPrevious()}\\\">\\n\" +\n    \"        <a href ng-click=\\\"selectPage(page - 1)\\\">{{getText('previous')}}</a>\\n\" +\n    \"    </li>\\n\" +\n    \"    <li ng-repeat=\\\"page in pages track by $index\\\" ng-class=\\\"{active: page.active}\\\">\\n\" +\n    \"        <a href ng-click=\\\"selectPage(page.number)\\\">{{page.text}}</a>\\n\" +\n    \"    </li>\\n\" +\n    \"    <li ng-if=\\\"directionLinks\\\" ng-class=\\\"{disabled: noNext()}\\\">\\n\" +\n    \"        <a href ng-click=\\\"selectPage(page + 1)\\\">{{getText('next')}}</a>\\n\" +\n    \"    </li>\\n\" +\n    \"    <li ng-if=\\\"boundaryLinks\\\" ng-class=\\\"{disabled: noNext()}\\\">\\n\" +\n    \"        <a href ng-click=\\\"selectPage(totalPages)\\\">{{getText('last')}}</a>\\n\" +\n    \"    </li>\\n\" +\n    \"</ul>\");\n}]);\n","template/table/table.html.js":"angular.module(\"xue/template/table/table.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"xue/template/table/table.html\",\n    \"<div class=\\\"xe-table-container\\\">\\n\" +\n    \"    <div class=\\\"xe-table-header\\\">\\n\" +\n    \"        \\n\" +\n    \"    </div>\\n\" +\n    \"    <div class=\\\"xe-table-content\\\">\\n\" +\n    \"\\n\" +\n    \"    </div>\\n\" +\n    \"    <div class=\\\"xe-table-footer\\\">\\n\" +\n    \"\\n\" +\n    \"    </div>\\n\" +\n    \"</div>\");\n}]);\n"}}