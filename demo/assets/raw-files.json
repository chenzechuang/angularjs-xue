{"banner":"/**\n * angularjs-xue\n * Homepage: https://github.com/zhangxuelian/angularjs-xue\n * \n * Version: 1.0.0 - 2020-02-21\n * Require angularjs version: 1.2.32\n * License: ISC\n */\n","cssBanner":"/* Include this file in your html if you are using the CSP mode. */\n\n","files":{"src/pagination/pagination.js":"angular.module('xue.pagination', [])\n\n  .controller('xuePaginationController', ['$scope', '$attrs', '$parse', function ($scope, $attrs, $parse) {\n    var self = this,\n      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n      setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;\n\n    this.init = function (ngModelCtrl_, config) {\n      ngModelCtrl = ngModelCtrl_;\n      this.config = config;\n\n      ngModelCtrl.$render = function () {\n        self.render();\n      };\n\n      if ($attrs.itemsPerPage) {\n        $scope.$parent.$watch($parse($attrs.itemsPerPage), function (value) {\n          self.itemsPerPage = parseInt(value, 10);\n          $scope.totalPages = self.calculateTotalPages();\n        });\n      } else {\n        this.itemsPerPage = config.itemsPerPage;\n      }\n    };\n\n    this.calculateTotalPages = function () {\n      var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);\n      return Math.max(totalPages || 0, 1);\n    };\n\n    this.render = function () {\n      $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;\n    };\n\n    $scope.selectPage = function (page) {\n      if ($scope.page !== page && page > 0 && page <= $scope.totalPages) {\n        ngModelCtrl.$setViewValue(page);\n        ngModelCtrl.$render();\n      }\n    };\n\n    $scope.getText = function (key) {\n      return $scope[key + 'Text'] || self.config[key + 'Text'];\n    };\n    $scope.noPrevious = function () {\n      return $scope.page === 1;\n    };\n    $scope.noNext = function () {\n      return $scope.page === $scope.totalPages;\n    };\n\n    $scope.$watch('totalItems', function () {\n      $scope.totalPages = self.calculateTotalPages();\n    });\n\n    $scope.$watch('totalPages', function (value) {\n      setNumPages($scope.$parent, value); // Readonly variable\n\n      if ($scope.page > value) {\n        $scope.selectPage(value);\n      } else {\n        ngModelCtrl.$render();\n      }\n    });\n  }])\n\n  .constant('xuePaginationConfig', {\n    itemsPerPage: 10,\n    boundaryLinks: false,\n    directionLinks: true,\n    firstText: '首页',\n    previousText: '上页',\n    nextText: '下页',\n    lastText: '尾页',\n    rotate: true\n  })\n\n  .directive('xuePagination', ['$parse', 'xuePaginationConfig', function ($parse, paginationConfig) {\n    return {\n      restrict: 'EA',\n      scope: {\n        totalItems: '=',\n        firstText: '@',\n        previousText: '@',\n        nextText: '@',\n        lastText: '@'\n      },\n      require: ['xuePagination', '?ngModel'],\n      controller: 'xuePaginationController',\n      templateUrl: function (element, attrs) {\n        return attrs.templateUrl || 'xue/template/pagination/pagination.html';\n      },\n      replace: true,\n      link: function (scope, element, attrs, ctrls) {\n        var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n        if (!ngModelCtrl) {\n          return; // do nothing if no ng-model\n        }\n\n        // Setup configuration parameters\n        var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,\n          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;\n        scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;\n        scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;\n\n        paginationCtrl.init(ngModelCtrl, paginationConfig);\n\n        if (attrs.maxSize) {\n          scope.$parent.$watch($parse(attrs.maxSize), function (value) {\n            maxSize = parseInt(value, 10);\n            paginationCtrl.render();\n          });\n        }\n\n        // Create page object used in template\n        function makePage(number, text, isActive) {\n          return {\n            number: number,\n            text: text,\n            active: isActive\n          };\n        }\n\n        function getPages(currentPage, totalPages) {\n          var pages = [];\n\n          // Default page limits\n          var startPage = 1, endPage = totalPages;\n          var isMaxSized = (angular.isDefined(maxSize) && maxSize < totalPages);\n\n          // recompute if maxSize\n          if (isMaxSized) {\n            if (rotate) {\n              // Current page is displayed in the middle of the visible ones\n              startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);\n              endPage = startPage + maxSize - 1;\n\n              // Adjust if limit is exceeded\n              if (endPage > totalPages) {\n                endPage = totalPages;\n                startPage = endPage - maxSize + 1;\n              }\n            } else {\n              // Visible pages are paginated with maxSize\n              startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;\n\n              // Adjust last page if limit is exceeded\n              endPage = Math.min(startPage + maxSize - 1, totalPages);\n            }\n          }\n\n          // Add page number links\n          for (var number = startPage; number <= endPage; number++) {\n            var page = makePage(number, number, number === currentPage);\n            pages.push(page);\n          }\n\n          // Add links to move between page sets\n          if (isMaxSized && !rotate) {\n            if (startPage > 1) {\n              var previousPageSet = makePage(startPage - 1, '...', false);\n              pages.unshift(previousPageSet);\n            }\n\n            if (endPage < totalPages) {\n              var nextPageSet = makePage(endPage + 1, '...', false);\n              pages.push(nextPageSet);\n            }\n          }\n\n          return pages;\n        }\n\n        var originalRender = paginationCtrl.render;\n        paginationCtrl.render = function () {\n          originalRender();\n          if (scope.page > 0 && scope.page <= scope.totalPages) {\n            scope.pages = getPages(scope.page, scope.totalPages);\n          }\n        };\n      }\n    };\n  }])\n\n  .constant('xuePagerConfig', {\n    itemsPerPage: 10,\n    previousText: '« 上页',\n    nextText: '下页 »',\n    align: true\n  })\n\n  .directive('xuePager', ['xuePagerConfig', function (pagerConfig) {\n    return {\n      restrict: 'EA',\n      scope: {\n        totalItems: '=',\n        previousText: '@',\n        nextText: '@'\n      },\n      require: ['xuePager', '?ngModel'],\n      controller: 'xuePaginationController',\n      templateUrl: function (element, attrs) {\n        return attrs.templateUrl || 'xue/template/pagination/pager.html';\n      },\n      replace: true,\n      link: function (scope, element, attrs, ctrls) {\n        var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n        if (!ngModelCtrl) {\n          return; // do nothing if no ng-model\n        }\n\n        scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;\n        paginationCtrl.init(ngModelCtrl, pagerConfig);\n      }\n    };\n  }]);","src/table/table.js":"angular.module('xue.table', ['xue.util.lang', 'xue.pagination'])\n    .directive('xueTable', ['xueUtilLang', function (xueUtilLang) {\n        return {\n            restrict: \"E\",\n            replace: true,\n            scope: {\n                tableConfig: '='\n            },\n            templateUrl: function (element, attrs) {\n                return attrs.templateUrl || 'xue/template/table/table.html';\n            },\n            link: function (scope, ele, attrs) {\n\n            }\n        };\n    }])","src/util/array.js":"angular.module('xue.util.array', []).service('xueUtilArray', [\n    function () {\n        /**\n         * 数组去重,数组元素为string\n         *\n         * @param {any} arr\n         * @returns\n         */\n        this.uniq = function (arr) {\n            var res = [];\n            var json = {};\n            for (var i = 0; i < arr.length; i++) {\n                if (!json[arr[i]]) {\n                    res.push(arr[i]);\n                    json[arr[i]] = 1;\n                }\n            }\n            return res;\n        };\n        /**\n         * 数组去重,数组元素为json\n         *\n         * @param {any} arr\n         * @param {any} key\n         * @returns\n         */\n        this.uniqJson = function (arr, key) {\n            var res = [];\n            var json = {};\n            angular.forEach(arr, function (item) {\n                if (!json[item[key]]) {\n                    res.push(item);\n                    json[item[key]] = 1;\n                }\n            });\n            return res;\n        };\n        /**\n         * 数组快速排序（数组对象为int型）\n         *\n         * @param {any} array\n         * @returns\n         */\n        /*eslint complexity: [\"error\", 7]*/\n        this.quickSort = function (array) {\n            function sort(prev, numsize) {\n                var nonius = prev;\n                var j = numsize - 1;\n                var flag = array[prev];\n                // eslint-disable-next-line no-extra-parens\n                if ((numsize - prev) > 1) {\n                    while (nonius < j) {\n                        for (; nonius < j; j--) {\n                            if (array[j] < flag) {\n                                //a[i] = a[j]; i += 1;\n                                array[nonius++] = array[j];\n                                break;\n                            }\n                        }\n                        for (; nonius < j; nonius++) {\n                            if (array[nonius] > flag) {\n                                array[j--] = array[nonius];\n                                break;\n                            }\n                        }\n                    }\n                    array[nonius] = flag;\n                    sort(0, nonius);\n                    sort(nonius + 1, numsize);\n                }\n            }\n            sort(0, array.length);\n            return array;\n        };\n        /**\n         * 从数组中查找对象属性值，返回下标（同用于判断数组中是否存在某对象）\n         * ps：数组对象为json\n         * @param {any} arr\n         * @param {any} key\n         * @param {any} value\n         * @returns\n         */\n        this.findObjIndex = function (arr, key, value) {\n            try {\n                for (var i = 0; i < arr.length; i++) {\n                    if (arr[i][key] === value) {\n                        return i;\n                    }\n                }\n                return -1;\n            } catch (e) {\n                return -1;\n            }\n        };\n        /**\n         * 从数组中查找值，返回下标（同用于判断数组中是否存在某对象）\n         * ps:数组对象为string\n         * @param {any} arr\n         * @param {any} value\n         * @returns\n         */\n        this.findStrIndex = function (arr, value) {\n            for (var i = 0; i < arr.length; i++) {\n                if (arr[i] === value) {\n                    return i;\n                }\n            }\n            return -1;\n        };\n\n    }\n]);","src/util/collection.js":"angular.module('xue.util.collection', ['xue.util.lang'])\n    .service('xueUtilCollect', [\"xueUtilLang\", function (xueUtilLang) {\n        /**\n         * 从数组中查找对象值，返回数组\n         * ps：数组元素为json，匹配对象为数组\n         * @param {any} arr\n         * @param {any} key\n         * @param {any} valueArr\n         * @returns\n         */\n        this.findWithArray = function (arr, key, valueArr) {\n            var ret = [];\n            for (var i = 0; i < arr.length; i++) {\n                for (var j in valueArr) {\n                    if (arr[i][key] === valueArr[j]) {\n                        ret.push(arr[i]);\n                        valueArr.splice(j, 1);\n                    }\n                }\n                if (valueArr.length === 0) {\n                    return ret;\n                }\n            }\n            return ret;\n        };\n        /**\n         * 从数组中查找对象值，返回对象\n         * ps：数组元素为json\n         * @param {any} arr\n         * @param {any} key\n         * @param {any} value\n         * @returns\n         */\n        this.findWithVal = function (arr, key, value) {\n            try {\n                for (var i = 0; i < arr.length; i++) {\n                    if (arr[i][key] === value) {\n                        return arr[i];\n                    }\n                }\n                return '';\n            } catch (e) {\n                return '';\n            }\n        };\n        /**\n         * 移除对象中值为空的项\n         *\n         * @param {obj} obj\n         * @returns\n         */\n        this.removeEmptyField = function (json) {\n            var newJson = {};\n            angular.forEach(json, function (item, i) {\n                if (item) {\n                    newJson[i] = item;\n                }\n            });\n            return newJson;\n        };\n        /**\n         * 移除数组中对象某属性值为空的项\n         *\n         * @param {array} array\n         * @returns\n         */\n        this.removeEmptyItem = function (array) {\n            var newArray = [];\n            for (var i = 0; i < array.length; i++) {\n                var newObj = {};\n                for (var j in array[i]) {\n                    if (array[i][j]) {\n                        newObj[j] = array[i][j];\n                    }\n                }\n                newArray.push(newObj);\n            }\n            return newArray;\n        };\n        /**\n         * 根据数组中对象的某个属性进行排序\n         * @param {Array} arr 数组\n         * @param {String} field 字段名\n         * @param {Boolean} order 排序方式 默认正序 true 倒序 false\n         * @param {String} type 排序类型 默认为0 数值类型 0 字符类型 1\n         */\n        /*eslint complexity: [\"error\", 8]*/\n        this.sortByfield = function (arr, field, order, type) {\n            var res = [];\n            if (arr.length && field) {\n                if (typeof order === 'undefined') {\n                    order = true;\n                } else {\n                    order = !!order;\n                }\n                if (typeof type === 'undefined') {\n                    type = isNaN(parseInt(arr[0][field], 0)) ? 1 : 0;\n                } else {\n                    type = type === 1 ? 1 : 0;\n                }\n                if (type === 0) {\n                    var compare = function () {\n                        return function (a, b) {\n                            var res;\n                            if (order) {\n                                res = a[field] - b[field];\n                            } else {\n                                res = b[field] - a[field];\n                            }\n                            return res;\n                        };\n                    };\n                    arr.sort(compare(field, order));\n                } else {\n                    var compareStr = function () {\n                        var e = order ? 1 : -1;\n                        return function (a, b) {\n                            var res;\n                            if (a[field] < b[field]) {\n                                res = -1 * e;\n                            } else if (a[field] > b[field]) {\n                                res = 1 * e;\n                            } else {\n                                res = 0;\n                            }\n                            return res;\n                        };\n                    };\n                    arr.sort(compareStr(field, order));\n                }\n                res = arr;\n            }\n            return res;\n        };\n        /**\n         * 判断是几维数组(返回数组中最大的维度)\n         */\n        this.arrDimension = function (arr, dimension) {\n            if (!dimension) {\n                dimension = 0;\n            }\n            var res;\n            if (arr instanceof Array) {\n                dimension++;\n                var maxDimension = 0,\n                    tempDimension = dimension,\n                    temp = 0;\n                for (var i = 0; i < arr.length; i++) {\n                    temp = this.arrDimension(arr[i], tempDimension);\n                    if (temp > maxDimension) {\n                        maxDimension = temp;\n                    }\n                }\n                res = maxDimension;\n            } else {\n                res = dimension;\n            }\n            return res;\n        };\n        /**\n         * 获取字节长度（英文数字占1个字符，中文汉字占2个字符）\n         * @param {string} str \n         */\n        this.getByteLen = function (str) {\n            var len = 0;\n            for (var i = 0; i < str.length; i++) {\n                var c = str.charCodeAt(i);\n                //单字节加1\n                if (c >= 0x0001 && c <= 0x007e || c >= 0xff60 && c <= 0xff9f) {\n                    len++;\n                } else {\n                    len += 2;\n                }\n            }\n            return len;\n        };\n        /**\n         * 按长度切割数组/字符串\n         * @param {array/string} param \n         * @param {int} len 中文字符长度，通过字节长度来切割的，则字节长度为len的两倍\n         * @param {bool} isByteLen 是否是字节长度 (目前仅字符串支持通过字节长度切割)\n         */\n        /*eslint complexity: [\"error\", 10]*/\n        this.sliceByLen = function (param, len, isByteLen) {\n            try {\n                var newArr = [],\n                    i;\n                if (isByteLen && xueUtilLang.isType(param || '', 'string')) {\n                    var byteLen = len * 2,\n                        tempStr = '',\n                        tempCount = 0;\n                    for (i = 0; i < param.length; i++) {\n                        tempCount += this.getByteLen(param.charAt(i));\n                        tempStr += param.charAt(i);\n                        if (tempCount >= byteLen) {\n                            newArr.push(tempStr);\n                            tempStr = '';\n                            tempCount = 0;\n                        }\n                    }\n                    if (tempCount) {\n                        newArr.push(tempStr);\n                    }\n                } else {\n                    var sliceTime = Math.ceil(param.length / len);\n                    for (i = 0; i < sliceTime; i++) {\n                        newArr.push(param.slice(i * len, i * len + len));\n                    }\n                }\n                return newArr;\n            } catch (e) {\n                return param || [];\n            }\n        };\n    }]);","src/util/date.js":"angular.module('xue.util.date', ['xue.util.lang'])\n    .service('xueUtilDate', ['xueUtilLang', function (xueUtilLang) {\n        var self = this;\n        /**\n         * 格式化时间\n         * 根据给定格式格式化时间 时间可以是标准时间或者符合时间格式的字符串\n         * @param {any} date /Mon Nov 20 2017 14:28:48 GMT+0800 (中国标准时间)/ 2020-2-20\n         * @param {string} fmt 可选 时间格式 默认YYYY-MM-DD hh:mm:ss\n         * @returns {String} /2016-01-01 23:59:59/\n         */\n        this.formatDate = function (date, fmt) {\n            date = new Date(date);\n            if (!xueUtilLang.isDate(date)) {\n                return \"Invalid Date\";\n            }\n            fmt = fmt ? fmt : \"YYYY-MM-DD hh:mm:ss\";\n            var opt = {\n                \"Y+\": date.getFullYear().toString(), // 年\n                \"M+\": (date.getMonth() + 1).toString(), // 月\n                \"D+\": date.getDate().toString(), // 日\n                \"h+\": date.getHours().toString(), // 时\n                \"m+\": date.getMinutes().toString(), // 分\n                \"s+\": date.getSeconds().toString() // 秒\n                // 有其他格式化字符需求可以继续添加，必须转化成字符串\n            };\n            for (var k in opt) {\n                var ret = new RegExp(\"(\" + k + \")\").exec(fmt);\n                if (ret) {\n                    fmt = fmt.replace(ret[1], (ret[1].length == 1) ? (opt[k]) : (opt[k].padStart(ret[1].length, \"0\")))\n                }\n            }\n            return fmt;\n        }\n        /**\n         * 获取当前时间\n         * @param {string} fmt 可选 时间格式 默认YYYY-MM-DD hh:mm:ss\n         * 获取当前年月日 YYYY-MM-DD\n         * 获取当前时分秒 hh:mm:ss\n         * @returns {String} /2016-01-01 23:59:59/\n         */\n        this.getCurrentFmtDate = function (fmt) {\n            var date = new Date();\n            return self.formatDate(date, fmt);\n        }\n        /**\n         * 获取指日期增加(减少)年/月/日/时/分/秒 之后的时间\n         * @param {string} dateStr 指定时间\n         * @param {number} number 需要增加或减少的数值 正数指定时间增加 负数初始时间减少 \n         * @param {string} type 需要增加(减少)的时间类型 years/months/days/hours/minutes/seconds\n         * @param {string} fmt 可选 时间格式 默认YYYY-MM-DD hh:mm:ss\n         * @returns {string}\n         */\n        this.dateAddNum = function (dateStr, type, number, fmt) {\n            var tempDate = new Date(dateStr); // 把日期字符串转换成日期格式\n            if (!xueUtilLang.isDate(tempDate)) {\n                return \"Invalid Date\";\n            }\n            switch (type) {\n                case \"years\":\n                    tempDate.setFullYear(tempDate.getFullYear() + number);\n                    break;\n                case \"months\":\n                    tempDate.setMonth(tempDate.getMonth() + number);\n                    break;\n                case \"days\":\n                    tempDate.setDate(tempDate.getDate() + number);\n                    break;\n                case \"hours\":\n                    tempDate.setHours(tempDate.getHours() + number);\n                    break;\n                case \"minutes\":\n                    tempDate.setMinutes(tempDate.getMinutes() + number);\n                    break;\n                case \"seconds\":\n                    tempDate.setSeconds(tempDate.getSeconds() + number);\n                    break;\n            }\n            return self.formatDate(tempDate, fmt);\n        }\n        /**\n         * 获取日期最大值\n         * 根据距 1970年1月1日 的毫秒数来比较获取日期的最大值\n         * \n         * @param {arr} dateArr 需要比较的日期数组 数组项可以是标准时间或者符合时间格式的字符串\n         * @returns {string}\n         */\n        this.maxDate = function (dateArr) {\n            if (!Array.isArray(dateArr) || !dateArr.length) {\n                return undefined;\n            }\n            if (dateArr.length === 1) {\n                return dateArr[0];\n            }\n            var max = dateArr.reduce(function (date1, date2) {\n                var d1 = new Date(date1),\n                    d2 = new Date(date2);\n                if (!xueUtilLang.isDate(d1)) {\n                    return date2;\n                } else if (!xueUtilLang.isDate(d2)) {\n                    return date1;\n                }\n                if (Date.parse(d1) - Date.parse(d2) > 0) {\n                    return date1;\n                } else {\n                    return date2;\n                }\n            })\n            if (!xueUtilLang.isDate(new Date(max))) {\n                return undefined;\n            }\n            return max;\n        }\n        /**\n         * 获取日期最小值\n         * 根据距 1970年1月1日 的毫秒数来比较获取日期的最小值\n         * \n         * @param {arr} dateArr 需要比较的日期数组 数组项可以是标准时间或者符合时间格式的字符串\n         * @returns {string}\n         */\n        this.minDate = function (dateArr) {\n            if (!Array.isArray(dateArr) || !dateArr.length) {\n                return undefined;\n            }\n            if (dateArr.length === 1) {\n                return dateArr[0];\n            }\n            var min = dateArr.reduce(function (date1, date2) {\n                var d1 = new Date(date1),\n                    d2 = new Date(date2);\n                if (!xueUtilLang.isDate(d1)) {\n                    return date2;\n                } else if (!xueUtilLang.isDate(d2)) {\n                    return date1;\n                }\n                if (Date.parse(d1) - Date.parse(d2) > 0) {\n                    return date2;\n                } else {\n                    return date1;\n                }\n            })\n            if (!xueUtilLang.isDate(new Date(min))) {\n                return undefined;\n            }\n            return min;\n        }\n        /**\n         * 获取两个日期的间隔对象\n         * 返回一个包含两个日期的天、小时、分钟、秒、毫秒及大小的对象\n         * \n         * @param {date} start 比较初始时间\n         * @param {date} end 比较结束时间\n         * @returns {obj} \n         */\n        this.timeInterval = function (start, end) {\n            var startTime = Date.parse(start.replace(/-/g, '/')); //开始时间\n            var endTime = Date.parse(end.replace(/-/g, '/')); //结束时间\n            var usedTime = Math.abs(parseFloat(startTime) - parseFloat(endTime)); //两个时间戳相差的毫秒数\n            var flag = ((startTime - endTime) > 0) ? '-' : '+';\n            var days = Math.floor(usedTime / (24 * 3600 * 1000));\n            //计算出小时数\n            var leave1 = usedTime % (24 * 3600 * 1000); //计算天数后剩余的毫秒数\n            var hours = Math.floor(leave1 / (3600 * 1000));\n            //计算相差分钟数\n            var leave2 = leave1 % (3600 * 1000); //计算小时数后剩余的毫秒数\n            var minutes = Math.floor(leave2 / (60 * 1000));\n            var seconds = Math.floor((usedTime - days * 24 * 60 * 60 * 1000 - hours * 60 * 60 * 1000 - minutes * 60 * 1000) / 1000); //取得算出分后剩余的秒数\n\n            var timeIntervalObj = {\n                days: days,\n                hours: hours,\n                minutes: minutes,\n                seconds: seconds,\n                usedTime: usedTime,\n                flag: flag\n            };\n            return timeIntervalObj;\n        };\n    }]);","src/util/function.js":"angular.module('xue.util.function', ['xue.util.lang'])\n    .service('xueUtilFunc', [\"xueUtilLang\", function (xueUtilLang) {\n        var self = this;\n        var FUNC_ERROR_TEXT = 'Expected a function';\n        var nativeMax = Math.max,\n            nativeMin = Math.min;\n        /**\n         * 创建一个调用func的函数，通过this绑定和创建函数的参数调用func，\n         * 调用次数不超过 n 次。 之后再调用这个函数，将返回一次最后调用func的结果。\n         *\n         * @param {number} n 超过多少次不再调用func（限制调用func 的次数）\n         * @param {Function} func 限制执行的函数.\n         * @returns {Function} 返回新的限定函数.\n         */\n        this.before = function (n, func) {\n            var result;\n            if (typeof func !== 'function') {\n                throw new TypeError(FUNC_ERROR_TEXT);\n            }\n            n = parseInt(n, 0);\n            return function () {\n                if (--n >= 0) {\n                    result = func.apply(this, arguments);\n                }\n                if (n < 1) {\n                    func = undefined;\n                }\n                return result;\n            };\n        };\n        /**\n         * before的反向函数;此方法创建一个函数，当他被调用n或更多次之后将马上触发func\n         * \n         * @param {number} n 方法应该在调用多少次后才执行.\n         * @param {Function} func 用来限定的函数.\n         * @returns {Function} 返回新的限定函数.\n         */\n        this.after = function (n, func) {\n            if (typeof func !== 'function') {\n                throw new TypeError(FUNC_ERROR_TEXT);\n            }\n            n = parseInt(n, 0);\n            return function () {\n                if (--n < 1) {\n                    return func.apply(this, arguments);\n                }\n            };\n        };\n        /**\n         * 创建一个 debounced（防抖动）函数，该函数会从上一次被调用后，延迟 wait 毫秒后调用 func 方法。\n         *  debounced（防抖动）函数提供一个 cancel 方法取消延迟的函数调用以及 flush 方法立即调用。\n         *  可以提供一个 options（选项） 对象决定如何调用 func 方法，options.leading 与|或 options.trailing \n         * 决定延迟前后如何触发（是 先调用后等待 还是 先等待后调用）。 \n         * func 调用时会传入最后一次提供给 debounced（防抖动）函数 的参数。 \n         * 后续调用的 debounced（防抖动）函数返回是最后一次 func 调用的结果\n         *\n         * 注意: 如果 leading 和 trailing 选项为 true, 则 func 允许 trailing 方式调用的条件为: \n         * 在 wait 期间多次调用防抖方法。如果 wait 为 0 并且 leading 为 false, func调用将被推迟到下一个点，\n         * 类似setTimeout为0的超时。\n         *\n         * @param {Function} func 要防抖动的函数.\n         * @param {number} [wait=0] 需要延迟的毫秒数.\n         * @param {Object} [options={}] 选项对象.\n         * @param {boolean} [options.leading=false] 指定在延迟开始前调用\n         * @param {number} [options.maxWait] 设置 func 允许被延迟的最大值\n         * @param {boolean} [options.trailing=true] 指定在延迟结束后调用\n         * @returns {Function} 返回新的 debounced（防抖动）函数.\n         */\n        /*eslint complexity: [\"error\", 7]*/\n        this.debounce = function (func, wait, options) {\n            var lastArgs,\n                lastThis,\n                maxWait,\n                result,\n                timerId,\n                lastCallTime,\n                lastInvokeTime = 0,\n                leading = false,\n                maxing = false,\n                trailing = true;\n\n            if (typeof func !== 'function') {\n                throw new TypeError(FUNC_ERROR_TEXT);\n            }\n            wait = Number(wait) || 0;\n            if (xueUtilLang.isObject(options)) {\n                leading = !!options.leading;\n                maxing = 'maxWait' in options;\n                maxWait = maxing ? nativeMax(Number(options.maxWait) || 0, wait) : maxWait;\n                trailing = 'trailing' in options ? !!options.trailing : trailing;\n            }\n\n            function invokeFunc(time) {\n                var args = lastArgs,\n                    thisArg = lastThis;\n\n                lastArgs = lastThis = undefined;\n                lastInvokeTime = time;\n                result = func.apply(thisArg, args);\n                return result;\n            }\n\n            function leadingEdge(time) {\n                // Reset any `maxWait` timer.\n                lastInvokeTime = time;\n                // Start the timer for the trailing edge.\n                timerId = setTimeout(timerExpired, wait);\n                // Invoke the leading edge.\n                return leading ? invokeFunc(time) : result;\n            }\n\n            function remainingWait(time) {\n                var timeSinceLastCall = time - lastCallTime,\n                    timeSinceLastInvoke = time - lastInvokeTime,\n                    timeWaiting = wait - timeSinceLastCall;\n\n                return maxing ?\n                    nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) :\n                    timeWaiting;\n            }\n\n            function shouldInvoke(time) {\n                var timeSinceLastCall = time - lastCallTime,\n                    timeSinceLastInvoke = time - lastInvokeTime;\n\n                // Either this is the first call, activity has stopped and we're at the\n                // trailing edge, the system time has gone backwards and we're treating\n                // it as the trailing edge, or we've hit the `maxWait` limit.\n                return lastCallTime === undefined || timeSinceLastCall >= wait ||\n                    timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n            }\n\n            function timerExpired() {\n                var time = Date.now();\n                if (shouldInvoke(time)) {\n                    return trailingEdge(time);\n                }\n                // Restart the timer.\n                timerId = setTimeout(timerExpired, remainingWait(time));\n            }\n\n            function trailingEdge(time) {\n                timerId = undefined;\n\n                // Only invoke if we have `lastArgs` which means `func` has been\n                // debounced at least once.\n                if (trailing && lastArgs) {\n                    return invokeFunc(time);\n                }\n                lastArgs = lastThis = undefined;\n                return result;\n            }\n\n            function cancel() {\n                if (timerId !== undefined) {\n                    clearTimeout(timerId);\n                }\n                lastInvokeTime = 0;\n                lastArgs = lastCallTime = lastThis = timerId = undefined;\n            }\n\n            function flush() {\n                return timerId === undefined ? result : trailingEdge(Date.now());\n            }\n\n            function debounced() {\n                var time = Date.now(),\n                    isInvoking = shouldInvoke(time);\n\n                lastArgs = arguments;\n                lastThis = this;\n                lastCallTime = time;\n\n                if (isInvoking) {\n                    if (timerId === undefined) {\n                        return leadingEdge(lastCallTime);\n                    }\n                    if (maxing) {\n                        // Handle invocations in a tight loop.\n                        clearTimeout(timerId);\n                        timerId = setTimeout(timerExpired, wait);\n                        return invokeFunc(lastCallTime);\n                    }\n                }\n                if (timerId === undefined) {\n                    timerId = setTimeout(timerExpired, wait);\n                }\n                return result;\n            }\n            debounced.cancel = cancel;\n            debounced.flush = flush;\n            return debounced;\n        };\n\n        /**\n         * “delay”和“defer”的基本实现，接受“args”\n         *\n         * @private\n         * @param {Function} func 延迟加载的函数.\n         * @param {number} wait 延迟秒数.\n         * @param {Array} args 提供给func的参数.\n         * @returns {number|Object} 返回计时器id或timeout对象 \n         */\n        this._baseDelay = function (func, wait, args) {\n            if (typeof func !== 'function') {\n                throw new TypeError(FUNC_ERROR_TEXT);\n            }\n            return setTimeout(function () {\n                func.apply(undefined, args);\n            }, wait);\n        };\n        /**\n         * 推迟调用func，直到当前堆栈清理完毕。 调用时，任何附加\n         * \n         * @param {Function} func 要延迟的函数.\n         * @param {...*} [args] 会在调用时传给 func 的参数.\n         * @returns {number} 返回计时器 id.\n         */\n        this.defer = function (func, args) {\n            return self._baseDelay(func, 1, args);\n        };\n        /**\n         * 延迟 wait 毫秒后调用 func。 调用时，任何附加的参数会传给func\n         *\n         * @param {Function} func 要延迟的函数.\n         * @param {number} wait 要延迟的毫秒数.\n         * @param {...*} [args] 会在调用时传入到func的参数.\n         * @returns {number} 返回计时器id.\n         */\n        this.delay = function (func, wait, args) {\n            return self._baseDelay(func, Number(wait) || 0, args);\n        };\n        /**\n         * 创建一个只能调用 func 一次的函数。 重复调用返回第一次调用的结果。 \n         * func 调用时， this 绑定到创建的函数，并传入对应参数。\n         *\n         * @param {Function} func 指定的触发的函数.\n         * @returns {Function} 返回新的受限函数.\n         */\n        this.once = function (func) {\n            return self.before(1, func);\n        };\n        /**\n         * 创建一个函数，调用func时，this绑定到创建的新函数，把参数作为数组传入，类似于 Function#apply\n         *\n         * @param {Function} func 要应用传播参数的函数.\n         * @param {number} [start=0] spread 参数的开始位置.\n         * @returns {Function} 返回新的函数.\n         */\n        this.spread = function (func, start) {\n            if (typeof func !== 'function') {\n                throw new TypeError(FUNC_ERROR_TEXT);\n            }\n            start = !start ? 0 : nativeMax(parseInt(start, 0), 0);\n            return function () {\n                var args = Array.prototype.slice.call(arguments);\n                var array = args[start],\n                    otherArgs = args.slice(0, start);\n\n                if (array) {\n                    otherArgs = otherArgs.concat(array);\n                }\n                return func.apply(this, otherArgs);\n            };\n        };\n        /**\n         * 创建一个调用func的函数，thisArg绑定func函数中的 this (this的上下文为thisArg) ，\n         * 并且func函数会接收partials附加参数。\n         * \n         * @param {Function} func 绑定的函数.\n         * @param {*} thisArg 绑定的this对象.\n         * @param {...*} [partials] 附加的部分参数.\n         * @returns {Function} 返回新的绑定函数.\n         */\n        this.bind = function (func, thisArg) {\n            if (typeof func !== 'function') {\n                throw new TypeError(FUNC_ERROR_TEXT);\n            }\n            var outerArgs = Array.prototype.slice.call(arguments, 2);\n            //此处的arguments为调用此函数时传进来的参数；2代表只需要保存第二个参数之后的其他的参数\n            return function () { //返回值应该是一个函数\n                var innerArgs = Array.prototype.slice.call(arguments);\n                //此处的arguments为内部函数的参数\n                var finalArgs = outerArgs.concat(innerArgs);\n                return func.apply(thisArg, finalArgs); //使用apply方法来改变this的指向\n            };\n        };\n    }]);","src/util/lang.js":"angular.module(\"xue.util.lang\", []).service(\"xueUtilLang\", [\n    function() {\n        var self = this;\n        /** 对象类型 */\n        var objType = [\"Null\", \"Undefined\", \"Number\", \"Boolean\", \"String\", \"Object\", \"Function\", \"Array\", \"RegExp\", \"Date\"];\n\n        /**\n         * 判断是否为对象\n         *\n         * @param {any} obj\n         * @returns {boolean}\n         */\n        this.isObject = function(obj) {\n            var type = typeof obj;\n            return obj !== null && (type === \"object\" || type === \"function\");\n        };\n        /**\n         * 判断是否为函数\n         *\n         * @param {any} fn\n         * @returns {boolean}\n         */\n        this.isFunction = function(fn) {\n            return Object.prototype.toString.call(fn) === \"[object Function]\";\n        };\n        /**\n         * 判断是否为Json\n         * @param {any} json\n         * @returns {boolean}\n         */\n        this.isJson = function (json) {\n            return Object.prototype.toString.call(json) === \"[object Object]\";\n        };\n        /**\n         * 检查是否是原始Number数值型或者Number对象。\n         *\n         * @param {any} number\n         * @returns {boolean}\n         */\n        this.isNumber = function(number) {\n            return typeof number === 'number' || Object.prototype.toString.call(number) === \"[object Number]\";\n        };\n        /**\n         * 判断是否为Date对象\n         * @param {any} date\n         * @returns {boolean}\n         */\n        this.isDate = function(date) {\n            return date instanceof Date || Object.prototype.toString.call(date) === \"[object Date]\";\n        };\n        /**\n         * 判断是否为图片\n         * \n         * @param {any} path\n         * @returns {boolean}\n         */\n        this.isPicture = function (path) {\n            var fileReg = /(.*).(jpg|bmp|gif|ico|pcx|jpeg|tif|png|raw|tga)$/i;\n            try {\n                return fileReg.test(path);\n            } catch (e) {\n                return false;\n            }\n        };\n        /**\n         * 判断是否为空对象\n         *\n         * @param {any} obj\n         * @returns {boolean}\n         */\n        this.isObjectEmpty = function(obj) {\n            if (Object.getOwnPropertyNames) {\n                return (Object.getOwnPropertyNames(obj).length === 0);\n            } else {\n                var k;\n                for (k in obj) {\n                    if (Object.prototype.hasOwnProperty.call(k, obj)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        };\n        /**\n         * 判断对象类型\n         *\n         * @param {any} obj 对象object\n         * @param {any} type 对象类型\n         * @returns {boolean}\n         */\n        this.isType = function(obj, type) {\n            return this.getType(obj) === type;\n        };\n        /**\n         * 获取对象类型\n         *\n         * @param {any} obj 对象object\n         * @returns {string}\n         */\n        this.getType = function(obj) {\n            var map = {};\n            angular.forEach(objType, function(item) {\n                map[\"[object \" + item + \"]\"] = item.toLowerCase();\n            });\n            return map[Object.prototype.toString.call(obj)] || \"object\";\n        };\n        /**\n         * 复制对象\n         *\n         * @param {any} obj\n         * @param {any} deep 是否深度复制\n         * @returns {object}\n         */\n        this.copyObj = function(obj, deep) {\n            if (!self.isObject(obj)) {\n                return obj;\n            }\n            var i, target = self.isType(obj, \"array\") ? [] : {}, value, valueType;\n            for (i in obj) {\n                if (hasOwnProperty.call(obj, i)) {\n                    value = obj[i];\n                    valueType = self.getType(value);\n                    if (deep && (valueType === \"array\" || valueType === \"object\")) {\n                        target[i] = self.copyObj(value, deep);\n                    } else {\n                        target[i] = value;\n                    }\n                }\n            }\n            return target;\n        };\n        /**\n         * 匹配对象\n         * 检查对象是否包含要匹配的对象\n         *\n         * @param {any} obj 要检查的对象\n         * @param {any} source 要匹配的对象\n         * @returns {boolean}\n         */\n        this.isMatch = function(obj, source) {\n            if (!self.isObject(obj) || !self.isObject(source)) {\n                return false;\n            }\n            if (obj === source) {\n                return true;\n            }\n            var matchKeyArr = [], matchLen;\n            for (var k in Object(source)) {\n                if (hasOwnProperty.call(source, k)) {\n                    matchKeyArr.push(k);\n                }\n            }\n            matchLen = matchKeyArr.length;\n\n            while (matchLen--) {\n                var key = matchKeyArr[matchLen],\n                    value = source[key],\n                    childObj = self.isObject(value);\n                if (!obj[key]) {\n                    return false;\n                } \n                if (!childObj) {\n                    if (value !== obj[key]) {\n                        return false;\n                    }\n                } else {\n                    if (!self.isMatch(obj[key], value)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n        /**\n         * 判断是否为IE\n         */\n        this.isIE = function () {\n            return !!window.ActiveXObject || \"ActiveXObject\" in window;\n        };\n        /**\n         * 判断是否为IE8\n         */\n        this.isIE8 = function () {\n            var a = navigator.appVersion.split(\";\"), b;\n            //系统是32位时谷歌浏览器版本号没有';',长度为1,a[1]为undefined,replace方法报错\n            if (a.length > 1) {\n                b = a[1].replace(/[ ]/g, \"\");\n            } else {\n                return false;\n            }\n            return navigator.appName === \"Microsoft Internet Explorer\" && b === \"MSIE8.0\";\n        };\n    }\n]);\n","src/util/math.js":"angular.module(\"xue.util.math\", ['xue.util.lang'])\n    .service(\"xueUtilMath\", [\"xueUtilLang\", function(xueUtilLang) {\n        var self = this;\n        /**\n         * 加法（解决浮点精度问题）\n         * @param {number} number1 数值1\n         * @param {number} number2 数值2\n         */\n        this.addition = function(number1, number2) {\n            var decimalLen1, decimalLen2, maxLenPower;\n            try {\n                decimalLen1 = number1.toString().split(\".\")[1].length;\n            } catch (e) {\n                decimalLen1 = 0;\n            }\n            try {\n                decimalLen2 = number2.toString().split(\".\")[1].length;\n            } catch (e) {\n                decimalLen2 = 0;\n            }\n            maxLenPower = Math.pow(10, Math.max(decimalLen1, decimalLen2));\n            return (number1 * maxLenPower + number2 * maxLenPower) / maxLenPower;\n        };\n        /**\n         * 减法（解决浮点精度问题）\n         * @param {number} subtrahend 减数\n         * @param {number} minuend 被减数\n         */\n        this.subtraction = function(subtrahend, minuend) {\n            var decimalLen1, decimalLen2, maxLenPower, maxLen;\n            try {\n                decimalLen1 = subtrahend.toString().split(\".\")[1].length;\n            } catch (e) {\n                decimalLen1 = 0;\n            }\n            try {\n                decimalLen2 = minuend.toString().split(\".\")[1].length;\n            } catch (e) {\n                decimalLen2 = 0;\n            }\n            maxLen = Math.max(decimalLen1, decimalLen2);\n            maxLenPower = Math.pow(10, maxLen);\n            return Number(\n                ((subtrahend * maxLenPower - minuend * maxLenPower) / maxLenPower).toFixed(maxLen)\n            );\n        };\n        /**\n         * 乘法（解决浮点精度问题）\n         * @param {number} multiplier1 乘数1\n         * @param {number} multiplier2 乘数2\n         */\n        this.multiplication = function(multiplier1, multiplier2) {\n            var decimalLen = 0;\n            multiplier1 = multiplier1.toString();\n            multiplier2 = multiplier2.toString();\n            try {\n                decimalLen += multiplier1.split(\".\")[1].length;\n            } catch (e) {\n                decimalLen += 0;\n            }\n            try {\n                decimalLen += multiplier2.split(\".\")[1].length;\n            } catch (e) {\n                decimalLen += 0;\n            }\n            return Number(multiplier1.replace(\".\", \"\")) * Number(multiplier2.replace(\".\", \"\") /\n                Math.pow(10, decimalLen)\n            );\n        };\n        /**\n         * 除法（解决浮点精度问题）\n         * @param {number} divisor 除数\n         * @param {number} dividend 被除数\n         */\n        this.division = function(divisor, dividend) {\n            var decimalLen1, decimalLen2, nDivisor, nDividend;\n            try {\n                decimalLen1 = divisor.toString().split(\".\")[1].length;\n            } catch (e) {\n                decimalLen1 = 0;\n            }\n            try {\n                decimalLen2 = dividend.toString().split(\".\")[1].length;\n            } catch (e) {\n                decimalLen2 = 0;\n            }\n            nDivisor = Number(divisor.toString().replace(\".\", \"\"));\n            nDividend = Number(dividend.toString().replace(\".\", \"\"));\n            return this.multiplication(\n                nDivisor / nDividend,\n                Math.pow(10, decimalLen2 - decimalLen1)\n            );\n        };\n        /**\n         * 平均值（解决浮点精度问题）\n         * @param {arr} arr 要迭代的数组\n         */\n        this.mean = function(arr) {\n            if (!Array.isArray(arr) || !arr.length) {\n                return NaN;\n            }\n            var result, index = -1, length = arr.length;\n            while (++index < length) {\n                var current = arr[index];\n                if (current !== undefined) {\n                    result = result === undefined ? current : self.addition(result, current);\n                }\n            }\n            return result / length;\n        };\n        /**\n         * 获取数组最大值（解决浮点精度问题）\n         * @param {arr} arr 要迭代的数组\n         */\n        this.max = function(arr) {\n            if (!Array.isArray(arr) || !arr.length) {\n                return undefined;\n            }\n            var max = arr.reduce(function(a, b) {\n                if (!xueUtilLang.isNumber(a)) {\n                    return b;\n                } else if (!xueUtilLang.isNumber(b)) {\n                    return a;\n                }\n                if (self.subtraction(a, b) > 0) {\n                    return a;\n                } else {\n                    return b;\n                }\n            })\n            if (!xueUtilLang.isNumber(max)) {\n                return undefined;\n            }\n            return max;\n        };\n         /**\n         * 获取数组最小值（解决浮点精度问题）\n         * @param {arr} arr 要迭代的数组\n         */\n        this.min = function(arr) {\n            if (!Array.isArray(arr) || !arr.length) {\n                return undefined;\n            }\n            var min = arr.reduce(function(a, b) {\n                if (!xueUtilLang.isNumber(a)) {\n                    return b;\n                } else if (!xueUtilLang.isNumber(b)) {\n                    return a;\n                }\n                if (self.subtraction(a, b) < 0) {\n                    return a;\n                } else {\n                    return b;\n                }\n            })\n            if (!xueUtilLang.isNumber(min)) {\n                return undefined;\n            }\n            return min;\n        };\n         /**\n         * 数字根据精度四舍五入\n         * @param {number} number 要四舍五入的数字(包含科学计数法)\n         * @param {arr} precision 四舍五入的精度(负数表示整数位四舍五入取整)\n         */\n        this.round = function(number, precision) {\n            if (!xueUtilLang.isNumber(number)) {\n                return NaN;\n            } else if (!precision) {\n                return Math.round(number)\n            } else {\n                var pair = (number.toString() + 'e').split('e'),\n                value = Math.round(pair[0] + 'e' + (+pair[1] + precision));\n                pair = (value.toString() + 'e').split('e');\n                return +(pair[0] + 'e' + (+pair[1] - precision));\n            }\n        };\n    }\n]);\n","src/util/methods.js":"angular.module('xue.util.methods', [])\n    .service('xueUtilMethod', [function () {\n\n    }]);","src/util/number.js":"angular.module('xue.util.number', [])\n    .service('xueUtilNumber', [function () {\n        /**\n         * 检查 n 是否在 start 与 end 之间，但不包括 end。\n         * 如果 end 没有指定，那么 start 设置为0。 \n         * 如果 start 大于 end，那么参数会交换以便支持负范围。\n         *\n         * @param {number} number  要检查的值\n         * @param {number} start   开始范围\n         * @param {number} end     结束范围\n         * @returns\n         */\n        this.inRange = function (number, start, end) {\n            if (end === undefined) {\n                end = start;\n                start = 0;\n            }\n            return number >= Math.min(start, end) && number < Math.max(start, end);\n        };\n        /**\n         * 产生一个包括 lower 与 upper 之间的数。\n         * 如果只提供一个参数返回一个0到提供数之间的数。 \n         * 如果 floating 设为 true，或者 lower 或 upper 是浮点数，结果返回浮点数。\n         *\n         * @param {number}  lower     要检查的值\n         * @param {number}  upper     开始范围\n         * @param {boolean} floating  结束范围\n         * @returns\n         */\n        /*eslint complexity: [\"error\", { \"max\": 12 }]*/\n        this.random = function (lower, upper, floating) {\n            var INFINITY = 1 / 0,\n                MAX_INTEGER = Number.MAX_VALUE || 1.7976931348623157e308;\n\n            if (floating === undefined) {\n                if (typeof upper === \"boolean\") {\n                    floating = upper;\n                    upper = undefined;\n                } else if (typeof lower === \"boolean\") {\n                    floating = lower;\n                    lower = undefined;\n                }\n            }\n            if (lower === undefined && upper === undefined) {\n                lower = 0;\n                upper = 1;\n            } else {\n                lower = toFinite(lower);\n                if (upper === undefined) {\n                    upper = lower;\n                    lower = 0;\n                } else {\n                    upper = toFinite(upper);\n                }\n            }\n            if (lower > upper) {\n                var temp = lower;\n                lower = upper;\n                upper = temp;\n            }\n            if (floating || lower % 1 || upper % 1) {\n                return Math.min(\n                    lower +\n                    Math.random() *\n                    (upper -\n                        lower +\n                        Number.parseFloat(\"1e-\" + ((Math.random() + \"\").length - 1))),\n                    upper\n                );\n            }\n            return lower + Math.floor(Math.random() * (upper - lower + 1));\n\n            function toFinite(value) {\n                if (!value) {\n                    return value === 0 ? value : 0;\n                }\n                value = toNumber(value);\n                if (value === INFINITY || value === -INFINITY) {\n                    var sign = value < 0 ? -1 : 1;\n                    return sign * MAX_INTEGER;\n                }\n                return isNaN(value) ? 0 : value;\n            }\n\n            function isNaN(value) {\n                return isNumber(value) && value !== +value;\n            }\n\n            function isNumber(value) {\n                return typeof value === 'number' ||\n                    isObjectLike(value) && Object.prototype.toString.call(value) === '[object Number]';\n            }\n        };\n        /**\n         * 确认所给值只在min,max之间\n         * 如果所给值是在min,max之间，那么就直接返回该值\n         * 否则返回与所给值最接近的min值或max值\n         *\n         * @param {number}  number  被限制的值\n         * @param {number}  lower   下限\n         * @param {number}  upper   上限\n         * @returns\n         */\n        this.clamp = function (number, lower, upper) {\n            if (upper === undefined) {\n                upper = lower;\n                lower = undefined;\n            }\n            if (upper !== undefined) {\n                upper = toNumber(upper);\n                upper = isNaN(upper) ? 0 : upper;\n            }\n            if (lower !== undefined) {\n                lower = toNumber(lower);\n                lower = isNaN(lower) ? 0 : lower;\n            }\n            return baseClamp(toNumber(number), lower, upper);\n\n            function baseClamp(number, lower, upper) {\n                if (!isNaN(number)) {\n                    if (upper !== undefined) {\n                        number = number <= upper ? number : upper;\n                    }\n                    if (lower !== undefined) {\n                        number = number >= lower ? number : lower;\n                    }\n                }\n                return number;\n            }\n        };\n\n        function toNumber(value) {\n            if (typeof value === \"number\") {\n                return value;\n            }\n            if (isSymbol(value)) {\n                return 0 / 0;\n            }\n            return Number(value);\n        }\n\n        function isSymbol(value) {\n            return typeof value === \"symbol\" || isObjectLike(value) && Object.prototype.toString.call(value) === \"[object Symbol]\";\n        }\n\n        function isObjectLike(value) {\n            return typeof value === \"object\" && value !== null;\n        }\n\n    }]);","src/util/object.js":"angular.module('xue.util.object', [])\n    .service('xueUtilObject', [function () {\n        var self = this;\n        /**\n         * json中把空对象移除\n         *\n         * @param {any} json\n         * @returns\n         */\n        this.removeEmptyField = function (json) {\n            var newJson = {};\n            for (var key in json) {\n                if (json[key]) {\n                    newJson[key] = json[key];\n                }\n            }\n            return newJson;\n        };\n        /**\n         * json中把数组的对象中的空属性移除\n         *\n         * @param {any} json\n         * @returns\n         */\n        this.removeEmptyParams = function (array) {\n            var newArray = [];\n            for (var i = 0, len = array.length; i < len; i++) {\n                var newObj = {};\n                for (var j in array[i]) {\n                    if (array[i][j]) {\n                        newObj[j] = array[i][j];\n                    }\n                }\n                newArray.push(newObj);\n            }\n            return newArray;\n        };\n        /**\n         * 判断两个对象值是否相等(仅用于参数是对象的情况)\n         *\n         * @param {object} objA   \n         * @param {object} objB\n         * @returns 成功true，失败false\n         */\n        /*eslint complexity: [\"error\", { \"max\": 8 }]*/\n        this.isObjectValueEqual = function (objA, objB) {\n            if (typeof objA !== \"object\" || typeof objB !== \"object\") {\n                return false;\n            }\n            var aProps = Object.getOwnPropertyNames(objA);\n            var bProps = Object.getOwnPropertyNames(objB);\n            if (aProps.length !== bProps.length) {\n                return false;\n            }\n            for (var i = 0, len = aProps.length; i < len; i++) {\n                var propName = aProps[i];\n                var propA = objA[propName];\n                var propB = objB[propName];\n                if (typeof propA === 'object') {\n                    if (self.isObjectValueEqual(propA, propB)) {\n                        return true;\n                    }\n                    return false;\n                } else if (propA !== propB) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        /**\n         * 根据value找到对象的key路径值\n         *\n         * @param {object} obj   \n         * @param {any}    value\n         * @returns 成功返回的是路径数组，失败则是undefined\n         */\n        this.searchKeys = function (obj, value) {\n            for (var key in obj) {\n                if (obj[key]) {\n                    if (obj[key] === value || self.isObjectValueEqual(obj[key], value)) {\n                        return key.split(\",\");\n                    }\n                    if (typeof obj[key] === 'object') {\n                        var temp = self.searchKeys(obj[key], value);\n                        if (temp) {\n                            return (key + \",\" + temp).split(\",\");\n                        }\n                    }\n                }\n            }\n        };\n        /**\n         * 根据key路径找到对象的value值\n         *\n         * @param {object} obj  \n         * @param {array}  pathArr \n         * @param {number} index   一般不用传（默认为0）\n         * @returns 成功返回的是value，失败则是undefined\n         */\n        this.findValByPath = function (obj, pathArr, index) {\n            if (typeof obj !== \"object\" || Object.prototype.toString.call(pathArr) !== '[object Array]') {\n                throw new Error(\"参数有误\");\n            }\n            if (!pathArr.length) {\n                return obj;\n            }\n            index = index || 0;\n            if (index >= pathArr.length - 1) {\n                return obj[pathArr[index]];\n            }\n            return self.findValByPath(obj[pathArr[index]], pathArr, ++index);\n        };\n        /**\n         * object键值对换(如果 object 有重复的值，后面的值会覆盖前面的值)\n         *\n         * @param {object} obj\n         * @returns newObj 返回新的键值对换后的对象\n         */\n        this.reverseObject = function (obj) {\n            var newObj = {};\n            for (var key in obj) {\n                newObj[obj[key]] = key;\n            }\n            return newObj;\n        }\n    }]);","src/util/properties.js":"angular.module('xue.util.properties', [])\n    .service('xueUtilProperty', [function () {\n\n    }]);","src/util/seq.js":"angular.module('xue.util.seq', [])\n    .service('xueUtilSeq', [function () {\n\n    }]);","src/util/string.js":"angular.module('xue.util.string', [])\n    .service('xueUtilString', [function () {\n        //var self = this;\n        var reg = /^[A-Za-z]+$/;\n        // 判断字符串是否为英文\n        function checkEng(num) {\n            return reg.test(num);\n        }\n        function replaceEndIndex(string) {\n            for (var i = string.length - 1; i >= 0; i--) {\n                if (/[A-Za-z0-9]+/.test(string[i])) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n        function replaceStratIndex(string) {\n            for (var i = 0; i < string.length; i++) {\n                if (/[A-Za-z0-9]+/.test(string[i])) {\n                    return i;\n                }\n            }\n            return -1;\n        }\n        function lowerCaseHandle(string) {\n            var arr = [];\n            var index = 0;\n            for (var i = 1; i < string.length; i++) {\n                if (/[A-Z]+/.test(string[i]) && /[a-z]+/.test(string[i - 1])) {\n                    arr.push(string.slice(index, i));\n                    index = i;\n                }\n            }\n            arr.push(string.slice(index, string.length));\n            return arr;\n        }\n        /**\n         * 转换字符串string首字母为大写，剩下为小写\n         * \n         * @param {any} string\n         * @returns\n         */\n        this.capitalize = function (string) {\n            var str = string ? string.toString().toLowerCase() : '';\n            if (str.length < 2) {\n                return str.charAt(0).toUpperCase();\n            }\n            return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();\n        };\n        /**\n         * 检查字符串string是否包含target\n         * \n         * @param {any} String\n         * @param {any} target //目标字符串\n         * @param {any} position //检查的位置\n         * @returns\n         */\n        this.endsWith = function (string, target, position) {\n            if (!string || !target) {\n                return false;\n            }\n            var str = string.toString();\n            var tar = target.toString();\n            var pos = position ? parseInt(position, 0) : 0;\n            var index = str.indexOf(tar);\n            if (index !== -1 && (typeof position === 'undefined' || index === pos)) {\n                return true;\n            }\n            return false;\n        };\n        /**\n         * 转换字符串string以空格分开单词\n         * \n         * @param {any} String\n         * @returns\n         * 返回一个数组\n         */\n        this.lowerCase = function (string) {\n            string = string.toString().replace(/[^A-Za-z]/g, ' ');\n            var temp = string.split(' ');\n            var arr = [];\n            for (var i = 0; i < temp.length; i++) {\n                if (temp[i]) {\n                    if (/[A-Z]+/.test(temp[i].slice(1)) && /[a-z]+/.test(temp[i].slice(1))) {\n                        arr = arr.concat(lowerCaseHandle(temp[i]));\n                    } else if (temp[i].length === 2 && /[A-Z]+/.test(temp[i].slice(1))) {\n                        arr.push(temp[i][0]);\n                        arr.push(temp[i][1]);\n                    } else {\n                        arr.push(temp[i]);\n                    }\n                }\n            }\n            return arr;\n        };\n        /**\n         * 字符串头部/尾部补充\n         * @param {any} String\n         * @param {any} length //填充的长度\n         * @param {any} type   // 填充类型\n         * @param {any} chars  // 填充的字符串\n         * padStart('ab',4,'x');->xxab\n         * @returns\n         */\n        this.padChars = function (string, length, type, chars) {\n            string = string.toString();\n            length = parseInt(length, 0);\n            chars = chars ? chars : ' ';\n            var newString = '';\n            if (type === 'start') {\n                newString = string.padStart(length, chars);\n            }\n            else {\n                newString = string.padEnd(length, chars);\n            }\n            return newString;\n        };\n        /**\n         * 格式化文字\n         *\n         * @param {any} text\n         * @param {any} len\n         */\n        this.formatterText = function (text, len) {\n            var newText = text.trim();\n            var string = '';\n            if (newText.length) {\n                var length = len || 10;\n                if (newText.length > length) {\n                    string = newText.substring(0, length) + '...';\n                } else {\n                    string = newText;\n                }\n            }\n            return string;\n        };\n        /**\n         * 格式化长文字（中间省略）\n         * \n         * @param {any} text \n         * @param {any} len \n         */\n        this.formatLongText = function (text, len) {\n            var newText = text.trim();\n            var string = '';\n            if (newText.length) {\n                var length = len || (parseInt(len, 0) > 0 ? parseInt(len, 0) : 5);\n                if (newText.length > length * 2) {\n                    string = newText.substring(0, length) + '...' + newText.substring(newText.length - length, newText.length);\n                } else {\n                    string = newText;\n                }\n            }\n            return string;\n        };\n        /**\n         * 获取字节长度（英文数字占1个字符，中文汉字占2个字符）\n         * @param {string} str \n         */\n        this.getByteLen = function (str) {\n            var len = 0;\n            try {\n                for (var i = 0; i < str.length; i++) {\n                    var c = str.charCodeAt(i);\n                    //单字节加1\n                    if (c >= 0x0001 && c <= 0x007e || c >= 0xff60 && c <= 0xff9f) {\n                        len++;\n                    } else {\n                        len += 2;\n                    }\n                }\n            } catch (e) {\n                len = 0;\n            }\n            return len;\n        };\n        /**\n        * 过滤字符串中html标签（防止ssl攻击）\n        * @param {string} str \n        */\n        this.filterHtml = function (str) {\n            var string = '';\n            try {\n                string = str.replace(/&nbsp;/ig, '').replace(/<[^<>]+>/g, '');\n            } catch (e) {\n                string = '';\n            }\n            return string;\n        };\n        /**\n        * 重复 N 次给定字符串\n        * @param {string} string \n        * @param {string} len\n        */\n        this.repeat = function (string, len) {\n            var newString = '';\n            len = len ? len : 0;\n            for (var i = 0; i < len; i++) {\n                newString += string;\n            }\n            return newString;\n        };\n        /**\n        * 根据cahr 拆分字符串string\n        * @param {string} string \n        * @param {string} char\n        * @param {string} len\n        */\n        this.split = function (string, char, len) {\n            string = string.toString();\n            if (!char) {\n                return string;\n            }\n            var temp = string.split(char);\n            if (!len) {\n                return temp;\n            }\n            if (len < temp.length) {\n                temp = temp.splice(0, len);\n            }\n            return temp;\n        };\n        /**\n        * string字符串中移除前面和后面的 空格 或 指定的字符\n        * @param {string} string \n        * @param {string} chars\n        */\n        this.replace = function (string, chars) {\n            string = string.toString();\n            chars = chars ? '[' + chars + ']' : '';\n            string = string.replace(new RegExp(chars, 'g'), '');\n            return string.trim();\n        };\n        /**\n        * string字符串中移除后面的空格或指定的字符\n        * @param {string} string \n        * @param {string} chars\n        */\n        this.replaceEnd = function (string, chars) {\n            if (!string) {\n                return '';\n            }\n            chars = chars ? '[' + chars + ']' : '';\n            var index = replaceEndIndex(string);\n            var newString = '';\n            if (index !== -1) {\n                var start = string.slice(0, index);\n                var end = string.slice(index, string.length).replace(new RegExp(chars, 'g'), '').trim();\n                newString = start + end;\n            } else {\n                newString = string.replace(new RegExp(chars, 'g'), '').trim();\n            }\n            return newString;\n        };\n        /**\n        * string字符串中移除前面的空格或指定的字符\n        * @param {string} string \n        * @param {string} chars\n        */\n        this.replaceStrat = function (string, chars) {\n            if (!string) {\n                return '';\n            }\n            chars = chars ? '[' + chars + ']' : '';\n            var index = replaceStratIndex(string);\n            var newString = '';\n            if (index !== -1) {\n                var start = string.slice(0, index).replace(new RegExp(chars, 'g'), '').trim();\n                var end = string.slice(index, string.length);\n                newString = start + end;\n            } else {\n                newString = string.replace(new RegExp(chars, 'g'), '').trim();\n            }\n            return newString;\n        };\n    }]);","src/util/util.js":"angular.module('xue.util',[\n    'xue.util.array','xue.util.collection','xue.util.date','xue.util.lang',\n    'xue.util.math','xue.util.methods','xue.util.number','xue.util.object',\n    'xue.util.properties','xue.util.seq','xue.util.string','xue.util.function']);","template/pagination/pager.html.js":"angular.module(\"xue/template/pagination/pager.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"xue/template/pagination/pager.html\",\n    \"<ul class=\\\"pager\\\">\\n\" +\n    \"    <li ng-class=\\\"{disabled: noPrevious(), previous: align}\\\"><a href ng-click=\\\"selectPage(page - 1)\\\">{{getText('previous')}}</a></li>\\n\" +\n    \"    <li ng-class=\\\"{disabled: noNext(), next: align}\\\"><a href ng-click=\\\"selectPage(page + 1)\\\">{{getText('next')}}</a></li>\\n\" +\n    \"</ul>\");\n}]);\n","template/pagination/pagination.html.js":"angular.module(\"xue/template/pagination/pagination.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"xue/template/pagination/pagination.html\",\n    \"<ul class=\\\"xui-pagination-wrap\\\">\\n\" +\n    \"    <li ng-if=\\\"boundaryLinks\\\" ng-class=\\\"{disabled: noPrevious()}\\\">\\n\" +\n    \"        <a href ng-click=\\\"selectPage(1)\\\">{{getText('first')}}</a>\\n\" +\n    \"    </li>\\n\" +\n    \"    <li ng-if=\\\"directionLinks\\\" ng-class=\\\"{disabled: noPrevious()}\\\">\\n\" +\n    \"        <a href ng-click=\\\"selectPage(page - 1)\\\">{{getText('previous')}}</a>\\n\" +\n    \"    </li>\\n\" +\n    \"    <li ng-repeat=\\\"page in pages track by $index\\\" ng-class=\\\"{active: page.active}\\\">\\n\" +\n    \"        <a href ng-click=\\\"selectPage(page.number)\\\">{{page.text}}</a>\\n\" +\n    \"    </li>\\n\" +\n    \"    <li ng-if=\\\"directionLinks\\\" ng-class=\\\"{disabled: noNext()}\\\">\\n\" +\n    \"        <a href ng-click=\\\"selectPage(page + 1)\\\">{{getText('next')}}</a>\\n\" +\n    \"    </li>\\n\" +\n    \"    <li ng-if=\\\"boundaryLinks\\\" ng-class=\\\"{disabled: noNext()}\\\">\\n\" +\n    \"        <a href ng-click=\\\"selectPage(totalPages)\\\">{{getText('last')}}</a>\\n\" +\n    \"    </li>\\n\" +\n    \"</ul>\");\n}]);\n","template/table/table.html.js":"angular.module(\"xue/template/table/table.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"xue/template/table/table.html\",\n    \"<div class=\\\"xe-table-container\\\">\\n\" +\n    \"    <div class=\\\"xe-table-header\\\">\\n\" +\n    \"        \\n\" +\n    \"    </div>\\n\" +\n    \"    <div class=\\\"xe-table-content\\\">\\n\" +\n    \"\\n\" +\n    \"    </div>\\n\" +\n    \"    <div class=\\\"xe-table-footer\\\">\\n\" +\n    \"\\n\" +\n    \"    </div>\\n\" +\n    \"</div>\");\n}]);\n"}}
